{"version":3,"file":"index.js","sources":["../../src/roles/main.ts","../../src/roles/math.ts","../../src/roles/plugin.ts","../../src/roles/html.ts","../../src/roles/index.ts","../../node_modules/js-yaml/lib/js-yaml/common.js","../../node_modules/js-yaml/lib/js-yaml/exception.js","../../node_modules/js-yaml/lib/js-yaml/mark.js","../../node_modules/js-yaml/lib/js-yaml/type.js","../../node_modules/js-yaml/lib/js-yaml/schema.js","../../node_modules/js-yaml/lib/js-yaml/schema/failsafe.js","../../node_modules/js-yaml/lib/js-yaml/type/str.js","../../node_modules/js-yaml/lib/js-yaml/type/seq.js","../../node_modules/js-yaml/lib/js-yaml/type/map.js","../../node_modules/js-yaml/lib/js-yaml/type/null.js","../../node_modules/js-yaml/lib/js-yaml/type/bool.js","../../node_modules/js-yaml/lib/js-yaml/type/int.js","../../node_modules/js-yaml/lib/js-yaml/type/float.js","../../node_modules/js-yaml/lib/js-yaml/schema/json.js","../../node_modules/js-yaml/lib/js-yaml/schema/core.js","../../node_modules/js-yaml/lib/js-yaml/type/timestamp.js","../../node_modules/js-yaml/lib/js-yaml/type/binary.js","../../node_modules/js-yaml/lib/js-yaml/type/merge.js","../../node_modules/js-yaml/lib/js-yaml/type/omap.js","../../node_modules/js-yaml/lib/js-yaml/type/pairs.js","../../node_modules/js-yaml/lib/js-yaml/type/set.js","../../node_modules/js-yaml/lib/js-yaml/schema/default_safe.js","../../node_modules/js-yaml/lib/js-yaml/type/js/undefined.js","../../node_modules/js-yaml/lib/js-yaml/type/js/function.js","../../node_modules/js-yaml/lib/js-yaml/type/js/regexp.js","../../node_modules/js-yaml/lib/js-yaml/schema/default_full.js","../../node_modules/js-yaml/lib/js-yaml/loader.js","../../node_modules/js-yaml/lib/js-yaml/dumper.js","../../node_modules/js-yaml/lib/js-yaml.js","../../node_modules/js-yaml/index.js","../../src/directives/main.ts","../../src/nestedCoreParse.ts","../../src/directives/plugin.ts","../../src/directives/options.ts","../../src/directives/admonitions.ts","../../src/directives/code.ts","../../src/directives/images.ts","../../src/syntaxTree.ts","../../src/directives/tables.ts","../../src/directives/math.ts","../../src/directives/index.ts","../../src/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport type StateCore from \"markdown-it/lib/rules_core/state_core\"\nimport type Token from \"markdown-it/lib/token\"\n\n/** Data structure of a role */\nexport interface IRoleData {\n  /** The map of the containing inline token */\n  parentMap: [number, number] | null\n  // TODO how to get line and position in line?\n  content: string\n  // TODO validate/convert\n  options?: { [key: string]: any }\n}\n\n/** A class to define a single role */\nexport class Role {\n  public state: StateCore\n  constructor(state: StateCore) {\n    this.state = state\n  }\n  /** Convert the role to tokens */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  run(data: IRoleData): Token[] {\n    return []\n  }\n}\n\nexport class RawRole extends Role {\n  run(data: IRoleData): Token[] {\n    // TODO options\n    const token = new this.state.Token(\"code_inline\", \"code\", 0)\n    token.content = data.content\n    return [token]\n  }\n}\n\nexport const main = {\n  raw: RawRole\n}\n","/**\n * This module contains roles that relate to mathematics\n */\nimport type MarkdownIt from \"markdown-it/lib\"\nimport type Token from \"markdown-it/lib/token\"\nimport { IRoleData, Role } from \"./main\"\nimport { IOptions } from \"./types\"\n\nconst INLINE_MATH_RULE = \"math_inline\"\n\nexport class Math extends Role {\n  run(data: IRoleData): Token[] {\n    const inline = new this.state.Token(INLINE_MATH_RULE, \"span\", 0)\n    inline.attrSet(\"class\", \"math inline\")\n    inline.markup = \"$\"\n    inline.content = data.content\n    return [inline]\n  }\n}\n\nexport function inlineMathRenderer(md: MarkdownIt, options?: IOptions): void {\n  // Only create the renderer if it does not exist\n  // For example, this may be defined in markdown-it-dollarmath\n  if (!options?.roles?.math || md.renderer.rules[INLINE_MATH_RULE]) return\n\n  md.renderer.rules[INLINE_MATH_RULE] = (tokens, idx) => {\n    const renderer = options?.opts?.math?.renderer ?? (c => md.utils.escapeHtml(c))\n    const token = tokens[idx]\n    const content = token.content.trim()\n    const math = renderer(content, { displayMode: false })\n    return `<span class=\"${token.attrGet(\"class\")}\">${math}</span>`\n  }\n}\n\nexport const math = {\n  math: Math\n}\n","/** Parse a role, in MyST format */\n// Ported from https://github.com/executablebooks/markdown-it-py/blob/master/markdown_it/extensions/myst_role/index.py\n// MIT License: https://github.com/executablebooks/markdown-it-py/blob/master/LICENSE\n\nimport type MarkdownIt from \"markdown-it/lib\"\nimport type StateCore from \"markdown-it/lib/rules_core/state_core\"\nimport type StateInline from \"markdown-it/lib/rules_inline/state_inline\"\nimport { Role } from \"./main\"\nimport { IOptions } from \"./types\"\nimport { inlineMathRenderer } from \"./math\"\n\nexport default function rolePlugin(md: MarkdownIt, options: IOptions): void {\n  if (options.parseRoles) {\n    md.inline.ruler.before(\"backticks\", \"parse_roles\", roleRule)\n  }\n  md.core.ruler.after(\n    options.rolesAfter || \"inline\",\n    \"run_roles\",\n    runRoles(options.roles || {})\n  )\n  // fallback renderer for unhandled roles\n  md.renderer.rules[\"role\"] = (tokens, idx) => {\n    const token = tokens[idx]\n    return `<span class=\"role-unhandled\"><mark>${token.meta.name}</mark><code>${token.content}</code></span>`\n  }\n\n  // TODO: when another renderer comes up, refactor into something a bit more scalable\n  inlineMathRenderer(md, options)\n\n  // TODO role_error renderer\n}\n\nfunction roleRule(state: StateInline, silent: boolean): boolean {\n  // Check if the role is escaped\n  if (state.src.charCodeAt(state.pos - 1) === 0x5c) {\n    /* \\ */\n    // TODO: this could be improved in the case of edge case '\\\\{', also multi-line\n    return false\n  }\n  const match = ROLE_PATTERN.exec(state.src.slice(state.pos))\n  if (match == null) return false\n  const [str, name, , content] = match\n  // eslint-disable-next-line no-param-reassign\n  state.pos += str.length\n\n  if (!silent) {\n    const token = state.push(\"role\", \"\", 0)\n    token.meta = { name }\n    token.content = content\n  }\n  return true\n}\n\n// MyST role syntax format e.g. {role}`text`\nlet _x: RegExp\ntry {\n  _x = new RegExp(\"^\\\\{([a-zA-Z_\\\\-+:]{1,36})\\\\}(`+)(?!`)(.+?)(?<!`)\\\\2(?!`)\")\n} catch (error) {\n  // Safari does not support negative look-behinds\n  // This is a slightly down-graded variant, as it does not require a space.\n  _x = /^\\{([a-zA-Z_\\-+:]{1,36})\\}(`+)(?!`)(.+?)\\2(?!`)/\n}\nconst ROLE_PATTERN = _x\n\n/** Run all roles, replacing the original token */\nfunction runRoles(roles: {\n  [key: string]: typeof Role\n}): (state: StateCore) => boolean {\n  function func(state: StateCore): boolean {\n    for (const token of state.tokens) {\n      if (token.type === \"inline\" && token.children) {\n        const childTokens = []\n        for (const child of token.children) {\n          // TODO role name translations\n          if (child.type === \"role\" && child.meta && child.meta.name in roles) {\n            try {\n              const role = new roles[child.meta.name](state)\n              const newTokens = role.run({\n                parentMap: token.map,\n                content: child.content\n              })\n              childTokens.push(...newTokens)\n            } catch (err) {\n              const errorToken = new state.Token(\"role_error\", \"\", 0)\n              errorToken.content = child.content\n              errorToken.info = child.info\n              errorToken.meta = child.meta\n              errorToken.map = child.map\n              errorToken.meta.error_message = (err as Error).message\n              errorToken.meta.error_name = (err as Error).name\n              childTokens.push(errorToken)\n            }\n          } else {\n            childTokens.push(child)\n          }\n        }\n        token.children = childTokens\n      }\n    }\n    return true\n  }\n  return func\n}\n","/**\n * This module contains roles that directly map to HTML semantic tags\n */\nimport type Token from \"markdown-it/lib/token\"\nimport { IRoleData, Role } from \"./main\"\n\nexport class Subscript extends Role {\n  run(data: IRoleData): Token[] {\n    const open = new this.state.Token(\"sub_open\", \"sub\", 1)\n    open.markup = \"~\"\n    const text = new this.state.Token(\"text\", \"\", 0)\n    text.content = data.content\n    const close = new this.state.Token(\"sub_close\", \"sub\", -1)\n    close.markup = \"~\"\n    return [open, text, close]\n  }\n}\n\nexport class Superscript extends Role {\n  run(data: IRoleData): Token[] {\n    const open = new this.state.Token(\"sup_open\", \"sup\", 1)\n    open.markup = \"~\"\n    const text = new this.state.Token(\"text\", \"\", 0)\n    text.content = data.content\n    const close = new this.state.Token(\"sup_close\", \"sup\", -1)\n    close.markup = \"~\"\n    return [open, text, close]\n  }\n}\n\nconst ABBR_PATTERN = /^(.+?)\\(([^()]+)\\)$/ // e.g. 'CSS (Cascading Style Sheets)'\n\nexport class Abbreviation extends Role {\n  run(data: IRoleData): Token[] {\n    const match = ABBR_PATTERN.exec(data.content)\n    const content = match?.[1]?.trim() ?? data.content.trim()\n    const title = match?.[2]?.trim() ?? null\n    const open = new this.state.Token(\"abbr_open\", \"abbr\", 1)\n    if (title) open.attrSet(\"title\", title)\n    const text = new this.state.Token(\"text\", \"\", 0)\n    text.content = content\n    const close = new this.state.Token(\"abbr_close\", \"abbr\", -1)\n    return [open, text, close]\n  }\n}\n\nexport const html = {\n  // Subscript\n  subscript: Subscript,\n  sub: Subscript,\n  // Superscript\n  superscript: Subscript,\n  sup: Superscript,\n  // Abbreviation\n  abbreviation: Abbreviation,\n  abbr: Abbreviation\n}\n","export { Role, main } from \"./main\"\nexport { default as rolePlugin } from \"./plugin\"\nexport type { IOptions as IRoleOptions } from \"./types\"\nexport { math } from \"./math\"\n\nimport { main } from \"./main\"\nimport { math } from \"./math\"\nimport { html } from \"./html\"\n\nexport const rolesDefault = { ...main, ...html, ...math }\n","'use strict';\n\n\nfunction isNothing(subject) {\n  return (typeof subject === 'undefined') || (subject === null);\n}\n\n\nfunction isObject(subject) {\n  return (typeof subject === 'object') && (subject !== null);\n}\n\n\nfunction toArray(sequence) {\n  if (Array.isArray(sequence)) return sequence;\n  else if (isNothing(sequence)) return [];\n\n  return [ sequence ];\n}\n\n\nfunction extend(target, source) {\n  var index, length, key, sourceKeys;\n\n  if (source) {\n    sourceKeys = Object.keys(source);\n\n    for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n      key = sourceKeys[index];\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n\nfunction repeat(string, count) {\n  var result = '', cycle;\n\n  for (cycle = 0; cycle < count; cycle += 1) {\n    result += string;\n  }\n\n  return result;\n}\n\n\nfunction isNegativeZero(number) {\n  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);\n}\n\n\nmodule.exports.isNothing      = isNothing;\nmodule.exports.isObject       = isObject;\nmodule.exports.toArray        = toArray;\nmodule.exports.repeat         = repeat;\nmodule.exports.isNegativeZero = isNegativeZero;\nmodule.exports.extend         = extend;\n","// YAML error class. http://stackoverflow.com/questions/8458984\n//\n'use strict';\n\nfunction YAMLException(reason, mark) {\n  // Super constructor\n  Error.call(this);\n\n  this.name = 'YAMLException';\n  this.reason = reason;\n  this.mark = mark;\n  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');\n\n  // Include stack trace in error object\n  if (Error.captureStackTrace) {\n    // Chrome and NodeJS\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    // FF, IE 10+ and Safari 6+. Fallback for others\n    this.stack = (new Error()).stack || '';\n  }\n}\n\n\n// Inherit from Error\nYAMLException.prototype = Object.create(Error.prototype);\nYAMLException.prototype.constructor = YAMLException;\n\n\nYAMLException.prototype.toString = function toString(compact) {\n  var result = this.name + ': ';\n\n  result += this.reason || '(unknown reason)';\n\n  if (!compact && this.mark) {\n    result += ' ' + this.mark.toString();\n  }\n\n  return result;\n};\n\n\nmodule.exports = YAMLException;\n","'use strict';\n\n\nvar common = require('./common');\n\n\nfunction Mark(name, buffer, position, line, column) {\n  this.name     = name;\n  this.buffer   = buffer;\n  this.position = position;\n  this.line     = line;\n  this.column   = column;\n}\n\n\nMark.prototype.getSnippet = function getSnippet(indent, maxLength) {\n  var head, start, tail, end, snippet;\n\n  if (!this.buffer) return null;\n\n  indent = indent || 4;\n  maxLength = maxLength || 75;\n\n  head = '';\n  start = this.position;\n\n  while (start > 0 && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {\n    start -= 1;\n    if (this.position - start > (maxLength / 2 - 1)) {\n      head = ' ... ';\n      start += 5;\n      break;\n    }\n  }\n\n  tail = '';\n  end = this.position;\n\n  while (end < this.buffer.length && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(end)) === -1) {\n    end += 1;\n    if (end - this.position > (maxLength / 2 - 1)) {\n      tail = ' ... ';\n      end -= 5;\n      break;\n    }\n  }\n\n  snippet = this.buffer.slice(start, end);\n\n  return common.repeat(' ', indent) + head + snippet + tail + '\\n' +\n         common.repeat(' ', indent + this.position - start + head.length) + '^';\n};\n\n\nMark.prototype.toString = function toString(compact) {\n  var snippet, where = '';\n\n  if (this.name) {\n    where += 'in \"' + this.name + '\" ';\n  }\n\n  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);\n\n  if (!compact) {\n    snippet = this.getSnippet();\n\n    if (snippet) {\n      where += ':\\n' + snippet;\n    }\n  }\n\n  return where;\n};\n\n\nmodule.exports = Mark;\n","'use strict';\n\nvar YAMLException = require('./exception');\n\nvar TYPE_CONSTRUCTOR_OPTIONS = [\n  'kind',\n  'resolve',\n  'construct',\n  'instanceOf',\n  'predicate',\n  'represent',\n  'defaultStyle',\n  'styleAliases'\n];\n\nvar YAML_NODE_KINDS = [\n  'scalar',\n  'sequence',\n  'mapping'\n];\n\nfunction compileStyleAliases(map) {\n  var result = {};\n\n  if (map !== null) {\n    Object.keys(map).forEach(function (style) {\n      map[style].forEach(function (alias) {\n        result[String(alias)] = style;\n      });\n    });\n  }\n\n  return result;\n}\n\nfunction Type(tag, options) {\n  options = options || {};\n\n  Object.keys(options).forEach(function (name) {\n    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n      throw new YAMLException('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n    }\n  });\n\n  // TODO: Add tag format check.\n  this.tag          = tag;\n  this.kind         = options['kind']         || null;\n  this.resolve      = options['resolve']      || function () { return true; };\n  this.construct    = options['construct']    || function (data) { return data; };\n  this.instanceOf   = options['instanceOf']   || null;\n  this.predicate    = options['predicate']    || null;\n  this.represent    = options['represent']    || null;\n  this.defaultStyle = options['defaultStyle'] || null;\n  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);\n\n  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n    throw new YAMLException('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n  }\n}\n\nmodule.exports = Type;\n","'use strict';\n\n/*eslint-disable max-len*/\n\nvar common        = require('./common');\nvar YAMLException = require('./exception');\nvar Type          = require('./type');\n\n\nfunction compileList(schema, name, result) {\n  var exclude = [];\n\n  schema.include.forEach(function (includedSchema) {\n    result = compileList(includedSchema, name, result);\n  });\n\n  schema[name].forEach(function (currentType) {\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {\n        exclude.push(previousIndex);\n      }\n    });\n\n    result.push(currentType);\n  });\n\n  return result.filter(function (type, index) {\n    return exclude.indexOf(index) === -1;\n  });\n}\n\n\nfunction compileMap(/* lists... */) {\n  var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {}\n      }, index, length;\n\n  function collectType(type) {\n    result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n  return result;\n}\n\n\nfunction Schema(definition) {\n  this.include  = definition.include  || [];\n  this.implicit = definition.implicit || [];\n  this.explicit = definition.explicit || [];\n\n  this.implicit.forEach(function (type) {\n    if (type.loadKind && type.loadKind !== 'scalar') {\n      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n  });\n\n  this.compiledImplicit = compileList(this, 'implicit', []);\n  this.compiledExplicit = compileList(this, 'explicit', []);\n  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);\n}\n\n\nSchema.DEFAULT = null;\n\n\nSchema.create = function createSchema() {\n  var schemas, types;\n\n  switch (arguments.length) {\n    case 1:\n      schemas = Schema.DEFAULT;\n      types = arguments[0];\n      break;\n\n    case 2:\n      schemas = arguments[0];\n      types = arguments[1];\n      break;\n\n    default:\n      throw new YAMLException('Wrong number of arguments for Schema.create function');\n  }\n\n  schemas = common.toArray(schemas);\n  types = common.toArray(types);\n\n  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {\n    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');\n  }\n\n  if (!types.every(function (type) { return type instanceof Type; })) {\n    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n  }\n\n  return new Schema({\n    include: schemas,\n    explicit: types\n  });\n};\n\n\nmodule.exports = Schema;\n","// Standard YAML's Failsafe schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2802346\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  explicit: [\n    require('../type/str'),\n    require('../type/seq'),\n    require('../type/map')\n  ]\n});\n","'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:str', {\n  kind: 'scalar',\n  construct: function (data) { return data !== null ? data : ''; }\n});\n","'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:seq', {\n  kind: 'sequence',\n  construct: function (data) { return data !== null ? data : []; }\n});\n","'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:map', {\n  kind: 'mapping',\n  construct: function (data) { return data !== null ? data : {}; }\n});\n","'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlNull(data) {\n  if (data === null) return true;\n\n  var max = data.length;\n\n  return (max === 1 && data === '~') ||\n         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));\n}\n\nfunction constructYamlNull() {\n  return null;\n}\n\nfunction isNull(object) {\n  return object === null;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:null', {\n  kind: 'scalar',\n  resolve: resolveYamlNull,\n  construct: constructYamlNull,\n  predicate: isNull,\n  represent: {\n    canonical: function () { return '~';    },\n    lowercase: function () { return 'null'; },\n    uppercase: function () { return 'NULL'; },\n    camelcase: function () { return 'Null'; }\n  },\n  defaultStyle: 'lowercase'\n});\n","'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlBoolean(data) {\n  if (data === null) return false;\n\n  var max = data.length;\n\n  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||\n         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));\n}\n\nfunction constructYamlBoolean(data) {\n  return data === 'true' ||\n         data === 'True' ||\n         data === 'TRUE';\n}\n\nfunction isBoolean(object) {\n  return Object.prototype.toString.call(object) === '[object Boolean]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:bool', {\n  kind: 'scalar',\n  resolve: resolveYamlBoolean,\n  construct: constructYamlBoolean,\n  predicate: isBoolean,\n  represent: {\n    lowercase: function (object) { return object ? 'true' : 'false'; },\n    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },\n    camelcase: function (object) { return object ? 'True' : 'False'; }\n  },\n  defaultStyle: 'lowercase'\n});\n","'use strict';\n\nvar common = require('../common');\nvar Type   = require('../type');\n\nfunction isHexCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||\n         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||\n         ((0x61/* a */ <= c) && (c <= 0x66/* f */));\n}\n\nfunction isOctCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));\n}\n\nfunction isDecCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));\n}\n\nfunction resolveYamlInteger(data) {\n  if (data === null) return false;\n\n  var max = data.length,\n      index = 0,\n      hasDigits = false,\n      ch;\n\n  if (!max) return false;\n\n  ch = data[index];\n\n  // sign\n  if (ch === '-' || ch === '+') {\n    ch = data[++index];\n  }\n\n  if (ch === '0') {\n    // 0\n    if (index + 1 === max) return true;\n    ch = data[++index];\n\n    // base 2, base 8, base 16\n\n    if (ch === 'b') {\n      // base 2\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (ch !== '0' && ch !== '1') return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'x') {\n      // base 16\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isHexCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n    // base 8\n    for (; index < max; index++) {\n      ch = data[index];\n      if (ch === '_') continue;\n      if (!isOctCode(data.charCodeAt(index))) return false;\n      hasDigits = true;\n    }\n    return hasDigits && ch !== '_';\n  }\n\n  // base 10 (except 0) or base 60\n\n  // value should not start with `_`;\n  if (ch === '_') return false;\n\n  for (; index < max; index++) {\n    ch = data[index];\n    if (ch === '_') continue;\n    if (ch === ':') break;\n    if (!isDecCode(data.charCodeAt(index))) {\n      return false;\n    }\n    hasDigits = true;\n  }\n\n  // Should have digits and should not end with `_`\n  if (!hasDigits || ch === '_') return false;\n\n  // if !base60 - done;\n  if (ch !== ':') return true;\n\n  // base60 almost not used, no needs to optimize\n  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));\n}\n\nfunction constructYamlInteger(data) {\n  var value = data, sign = 1, ch, base, digits = [];\n\n  if (value.indexOf('_') !== -1) {\n    value = value.replace(/_/g, '');\n  }\n\n  ch = value[0];\n\n  if (ch === '-' || ch === '+') {\n    if (ch === '-') sign = -1;\n    value = value.slice(1);\n    ch = value[0];\n  }\n\n  if (value === '0') return 0;\n\n  if (ch === '0') {\n    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n    if (value[1] === 'x') return sign * parseInt(value, 16);\n    return sign * parseInt(value, 8);\n  }\n\n  if (value.indexOf(':') !== -1) {\n    value.split(':').forEach(function (v) {\n      digits.unshift(parseInt(v, 10));\n    });\n\n    value = 0;\n    base = 1;\n\n    digits.forEach(function (d) {\n      value += (d * base);\n      base *= 60;\n    });\n\n    return sign * value;\n\n  }\n\n  return sign * parseInt(value, 10);\n}\n\nfunction isInteger(object) {\n  return (Object.prototype.toString.call(object)) === '[object Number]' &&\n         (object % 1 === 0 && !common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:int', {\n  kind: 'scalar',\n  resolve: resolveYamlInteger,\n  construct: constructYamlInteger,\n  predicate: isInteger,\n  represent: {\n    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },\n    octal:       function (obj) { return obj >= 0 ? '0'  + obj.toString(8) : '-0'  + obj.toString(8).slice(1); },\n    decimal:     function (obj) { return obj.toString(10); },\n    /* eslint-disable max-len */\n    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }\n  },\n  defaultStyle: 'decimal',\n  styleAliases: {\n    binary:      [ 2,  'bin' ],\n    octal:       [ 8,  'oct' ],\n    decimal:     [ 10, 'dec' ],\n    hexadecimal: [ 16, 'hex' ]\n  }\n});\n","'use strict';\n\nvar common = require('../common');\nvar Type   = require('../type');\n\nvar YAML_FLOAT_PATTERN = new RegExp(\n  // 2.5e4, 2.5 and integers\n  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n  // .2e4, .2\n  // special case, seems not from spec\n  '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n  // 20:59\n  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]*' +\n  // .inf\n  '|[-+]?\\\\.(?:inf|Inf|INF)' +\n  // .nan\n  '|\\\\.(?:nan|NaN|NAN))$');\n\nfunction resolveYamlFloat(data) {\n  if (data === null) return false;\n\n  if (!YAML_FLOAT_PATTERN.test(data) ||\n      // Quick hack to not allow integers end with `_`\n      // Probably should update regexp & check speed\n      data[data.length - 1] === '_') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlFloat(data) {\n  var value, sign, base, digits;\n\n  value  = data.replace(/_/g, '').toLowerCase();\n  sign   = value[0] === '-' ? -1 : 1;\n  digits = [];\n\n  if ('+-'.indexOf(value[0]) >= 0) {\n    value = value.slice(1);\n  }\n\n  if (value === '.inf') {\n    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n  } else if (value === '.nan') {\n    return NaN;\n\n  } else if (value.indexOf(':') >= 0) {\n    value.split(':').forEach(function (v) {\n      digits.unshift(parseFloat(v, 10));\n    });\n\n    value = 0.0;\n    base = 1;\n\n    digits.forEach(function (d) {\n      value += d * base;\n      base *= 60;\n    });\n\n    return sign * value;\n\n  }\n  return sign * parseFloat(value, 10);\n}\n\n\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\nfunction representYamlFloat(object, style) {\n  var res;\n\n  if (isNaN(object)) {\n    switch (style) {\n      case 'lowercase': return '.nan';\n      case 'uppercase': return '.NAN';\n      case 'camelcase': return '.NaN';\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '.inf';\n      case 'uppercase': return '.INF';\n      case 'camelcase': return '.Inf';\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '-.inf';\n      case 'uppercase': return '-.INF';\n      case 'camelcase': return '-.Inf';\n    }\n  } else if (common.isNegativeZero(object)) {\n    return '-0.0';\n  }\n\n  res = object.toString(10);\n\n  // JS stringifier can build scientific format without dots: 5e-100,\n  // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n}\n\nfunction isFloat(object) {\n  return (Object.prototype.toString.call(object) === '[object Number]') &&\n         (object % 1 !== 0 || common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:float', {\n  kind: 'scalar',\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: 'lowercase'\n});\n","// Standard YAML's JSON schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2803231\n//\n// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n// So, this schema is not such strict as defined in the YAML specification.\n// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  include: [\n    require('./failsafe')\n  ],\n  implicit: [\n    require('../type/null'),\n    require('../type/bool'),\n    require('../type/int'),\n    require('../type/float')\n  ]\n});\n","// Standard YAML's Core schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2804923\n//\n// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n// So, Core schema has no distinctions from JSON schema is JS-YAML.\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  include: [\n    require('./json')\n  ]\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar YAML_DATE_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9])'                    + // [2] month\n  '-([0-9][0-9])$');                   // [3] day\n\nvar YAML_TIMESTAMP_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9]?)'                   + // [2] month\n  '-([0-9][0-9]?)'                   + // [3] day\n  '(?:[Tt]|[ \\\\t]+)'                 + // ...\n  '([0-9][0-9]?)'                    + // [4] hour\n  ':([0-9][0-9])'                    + // [5] minute\n  ':([0-9][0-9])'                    + // [6] second\n  '(?:\\\\.([0-9]*))?'                 + // [7] fraction\n  '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute\n\nfunction resolveYamlTimestamp(data) {\n  if (data === null) return false;\n  if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n  return false;\n}\n\nfunction constructYamlTimestamp(data) {\n  var match, year, month, day, hour, minute, second, fraction = 0,\n      delta = null, tz_hour, tz_minute, date;\n\n  match = YAML_DATE_REGEXP.exec(data);\n  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n\n  if (match === null) throw new Error('Date resolve error');\n\n  // match: [1] year [2] month [3] day\n\n  year = +(match[1]);\n  month = +(match[2]) - 1; // JS month starts with 0\n  day = +(match[3]);\n\n  if (!match[4]) { // no hour\n    return new Date(Date.UTC(year, month, day));\n  }\n\n  // match: [4] hour [5] minute [6] second [7] fraction\n\n  hour = +(match[4]);\n  minute = +(match[5]);\n  second = +(match[6]);\n\n  if (match[7]) {\n    fraction = match[7].slice(0, 3);\n    while (fraction.length < 3) { // milli-seconds\n      fraction += '0';\n    }\n    fraction = +fraction;\n  }\n\n  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n  if (match[9]) {\n    tz_hour = +(match[10]);\n    tz_minute = +(match[11] || 0);\n    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n    if (match[9] === '-') delta = -delta;\n  }\n\n  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n\n  if (delta) date.setTime(date.getTime() - delta);\n\n  return date;\n}\n\nfunction representYamlTimestamp(object /*, style*/) {\n  return object.toISOString();\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:timestamp', {\n  kind: 'scalar',\n  resolve: resolveYamlTimestamp,\n  construct: constructYamlTimestamp,\n  instanceOf: Date,\n  represent: representYamlTimestamp\n});\n","'use strict';\n\n/*eslint-disable no-bitwise*/\n\nvar NodeBuffer;\n\ntry {\n  // A trick for browserified version, to not include `Buffer` shim\n  var _require = require;\n  NodeBuffer = _require('buffer').Buffer;\n} catch (__) {}\n\nvar Type       = require('../type');\n\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n\n  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) continue;\n\n    // Fail on illegal characters\n    if (code < 0) return false;\n\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return (bitlen % 8) === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx, tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = (bits << 6) | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    result.push((bits >> 16) & 0xFF);\n    result.push((bits >> 8) & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push((bits >> 10) & 0xFF);\n    result.push((bits >> 2) & 0xFF);\n  } else if (tailbits === 12) {\n    result.push((bits >> 4) & 0xFF);\n  }\n\n  // Wrap into Buffer for NodeJS and leave Array for browser\n  if (NodeBuffer) {\n    // Support node 6.+ Buffer API when available\n    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);\n  }\n\n  return result;\n}\n\nfunction representYamlBinary(object /*, style*/) {\n  var result = '', bits = 0, idx, tail,\n      max = object.length,\n      map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 3 === 0) && idx) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[(bits >> 18) & 0x3F];\n    result += map[(bits >> 12) & 0x3F];\n    result += map[(bits >> 6) & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[(bits >> 10) & 0x3F];\n    result += map[(bits >> 4) & 0x3F];\n    result += map[(bits << 2) & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[(bits >> 2) & 0x3F];\n    result += map[(bits << 4) & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(object) {\n  return NodeBuffer && NodeBuffer.isBuffer(object);\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n","'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlMerge(data) {\n  return data === '<<' || data === null;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:merge', {\n  kind: 'scalar',\n  resolve: resolveYamlMerge\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar _toString       = Object.prototype.toString;\n\nfunction resolveYamlOmap(data) {\n  if (data === null) return true;\n\n  var objectKeys = [], index, length, pair, pairKey, pairHasKey,\n      object = data;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    pairHasKey = false;\n\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    for (pairKey in pair) {\n      if (_hasOwnProperty.call(pair, pairKey)) {\n        if (!pairHasKey) pairHasKey = true;\n        else return false;\n      }\n    }\n\n    if (!pairHasKey) return false;\n\n    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n    else return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlOmap(data) {\n  return data !== null ? data : [];\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:omap', {\n  kind: 'sequence',\n  resolve: resolveYamlOmap,\n  construct: constructYamlOmap\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar _toString = Object.prototype.toString;\n\nfunction resolveYamlPairs(data) {\n  if (data === null) return true;\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    keys = Object.keys(pair);\n\n    if (keys.length !== 1) return false;\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return true;\n}\n\nfunction constructYamlPairs(data) {\n  if (data === null) return [];\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    keys = Object.keys(pair);\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return result;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:pairs', {\n  kind: 'sequence',\n  resolve: resolveYamlPairs,\n  construct: constructYamlPairs\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction resolveYamlSet(data) {\n  if (data === null) return true;\n\n  var key, object = data;\n\n  for (key in object) {\n    if (_hasOwnProperty.call(object, key)) {\n      if (object[key] !== null) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constructYamlSet(data) {\n  return data !== null ? data : {};\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:set', {\n  kind: 'mapping',\n  resolve: resolveYamlSet,\n  construct: constructYamlSet\n});\n","// JS-YAML's default schema for `safeLoad` function.\n// It is not described in the YAML specification.\n//\n// This schema is based on standard YAML's Core schema and includes most of\n// extra types described at YAML tag repository. (http://yaml.org/type/)\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  include: [\n    require('./core')\n  ],\n  implicit: [\n    require('../type/timestamp'),\n    require('../type/merge')\n  ],\n  explicit: [\n    require('../type/binary'),\n    require('../type/omap'),\n    require('../type/pairs'),\n    require('../type/set')\n  ]\n});\n","'use strict';\n\nvar Type = require('../../type');\n\nfunction resolveJavascriptUndefined() {\n  return true;\n}\n\nfunction constructJavascriptUndefined() {\n  /*eslint-disable no-undefined*/\n  return undefined;\n}\n\nfunction representJavascriptUndefined() {\n  return '';\n}\n\nfunction isUndefined(object) {\n  return typeof object === 'undefined';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:js/undefined', {\n  kind: 'scalar',\n  resolve: resolveJavascriptUndefined,\n  construct: constructJavascriptUndefined,\n  predicate: isUndefined,\n  represent: representJavascriptUndefined\n});\n","'use strict';\n\nvar esprima;\n\n// Browserified version does not have esprima\n//\n// 1. For node.js just require module as deps\n// 2. For browser try to require mudule via external AMD system.\n//    If not found - try to fallback to window.esprima. If not\n//    found too - then fail to parse.\n//\ntry {\n  // workaround to exclude package from browserify list.\n  var _require = require;\n  esprima = _require('esprima');\n} catch (_) {\n  /* eslint-disable no-redeclare */\n  /* global window */\n  if (typeof window !== 'undefined') esprima = window.esprima;\n}\n\nvar Type = require('../../type');\n\nfunction resolveJavascriptFunction(data) {\n  if (data === null) return false;\n\n  try {\n    var source = '(' + data + ')',\n        ast    = esprima.parse(source, { range: true });\n\n    if (ast.type                    !== 'Program'             ||\n        ast.body.length             !== 1                     ||\n        ast.body[0].type            !== 'ExpressionStatement' ||\n        (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&\n          ast.body[0].expression.type !== 'FunctionExpression')) {\n      return false;\n    }\n\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nfunction constructJavascriptFunction(data) {\n  /*jslint evil:true*/\n\n  var source = '(' + data + ')',\n      ast    = esprima.parse(source, { range: true }),\n      params = [],\n      body;\n\n  if (ast.type                    !== 'Program'             ||\n      ast.body.length             !== 1                     ||\n      ast.body[0].type            !== 'ExpressionStatement' ||\n      (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&\n        ast.body[0].expression.type !== 'FunctionExpression')) {\n    throw new Error('Failed to resolve function');\n  }\n\n  ast.body[0].expression.params.forEach(function (param) {\n    params.push(param.name);\n  });\n\n  body = ast.body[0].expression.body.range;\n\n  // Esprima's ranges include the first '{' and the last '}' characters on\n  // function expressions. So cut them out.\n  if (ast.body[0].expression.body.type === 'BlockStatement') {\n    /*eslint-disable no-new-func*/\n    return new Function(params, source.slice(body[0] + 1, body[1] - 1));\n  }\n  // ES6 arrow functions can omit the BlockStatement. In that case, just return\n  // the body.\n  /*eslint-disable no-new-func*/\n  return new Function(params, 'return ' + source.slice(body[0], body[1]));\n}\n\nfunction representJavascriptFunction(object /*, style*/) {\n  return object.toString();\n}\n\nfunction isFunction(object) {\n  return Object.prototype.toString.call(object) === '[object Function]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:js/function', {\n  kind: 'scalar',\n  resolve: resolveJavascriptFunction,\n  construct: constructJavascriptFunction,\n  predicate: isFunction,\n  represent: representJavascriptFunction\n});\n","'use strict';\n\nvar Type = require('../../type');\n\nfunction resolveJavascriptRegExp(data) {\n  if (data === null) return false;\n  if (data.length === 0) return false;\n\n  var regexp = data,\n      tail   = /\\/([gim]*)$/.exec(data),\n      modifiers = '';\n\n  // if regexp starts with '/' it can have modifiers and must be properly closed\n  // `/foo/gim` - modifiers tail can be maximum 3 chars\n  if (regexp[0] === '/') {\n    if (tail) modifiers = tail[1];\n\n    if (modifiers.length > 3) return false;\n    // if expression starts with /, is should be properly terminated\n    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;\n  }\n\n  return true;\n}\n\nfunction constructJavascriptRegExp(data) {\n  var regexp = data,\n      tail   = /\\/([gim]*)$/.exec(data),\n      modifiers = '';\n\n  // `/foo/gim` - tail can be maximum 4 chars\n  if (regexp[0] === '/') {\n    if (tail) modifiers = tail[1];\n    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);\n  }\n\n  return new RegExp(regexp, modifiers);\n}\n\nfunction representJavascriptRegExp(object /*, style*/) {\n  var result = '/' + object.source + '/';\n\n  if (object.global) result += 'g';\n  if (object.multiline) result += 'm';\n  if (object.ignoreCase) result += 'i';\n\n  return result;\n}\n\nfunction isRegExp(object) {\n  return Object.prototype.toString.call(object) === '[object RegExp]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:js/regexp', {\n  kind: 'scalar',\n  resolve: resolveJavascriptRegExp,\n  construct: constructJavascriptRegExp,\n  predicate: isRegExp,\n  represent: representJavascriptRegExp\n});\n","// JS-YAML's default schema for `load` function.\n// It is not described in the YAML specification.\n//\n// This schema is based on JS-YAML's default safe schema and includes\n// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.\n//\n// Also this schema is used as default base schema at `Schema.create` function.\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = Schema.DEFAULT = new Schema({\n  include: [\n    require('./default_safe')\n  ],\n  explicit: [\n    require('../type/js/undefined'),\n    require('../type/js/regexp'),\n    require('../type/js/function')\n  ]\n});\n","'use strict';\n\n/*eslint-disable max-len,no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar Mark                = require('./mark');\nvar DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\nvar DEFAULT_FULL_SCHEMA = require('./schema/default_full');\n\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\nvar CONTEXT_FLOW_IN   = 1;\nvar CONTEXT_FLOW_OUT  = 2;\nvar CONTEXT_BLOCK_IN  = 3;\nvar CONTEXT_BLOCK_OUT = 4;\n\n\nvar CHOMPING_CLIP  = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP  = 3;\n\n\nvar PATTERN_NON_PRINTABLE         = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS       = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI               = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction is_EOL(c) {\n  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);\n}\n\nfunction is_WHITE_SPACE(c) {\n  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);\n}\n\nfunction is_WS_OR_EOL(c) {\n  return (c === 0x09/* Tab */) ||\n         (c === 0x20/* Space */) ||\n         (c === 0x0A/* LF */) ||\n         (c === 0x0D/* CR */);\n}\n\nfunction is_FLOW_INDICATOR(c) {\n  return c === 0x2C/* , */ ||\n         c === 0x5B/* [ */ ||\n         c === 0x5D/* ] */ ||\n         c === 0x7B/* { */ ||\n         c === 0x7D/* } */;\n}\n\nfunction fromHexCode(c) {\n  var lc;\n\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  /*eslint-disable no-bitwise*/\n  lc = c | 0x20;\n\n  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {\n    return lc - 0x61 + 10;\n  }\n\n  return -1;\n}\n\nfunction escapedHexLen(c) {\n  if (c === 0x78/* x */) { return 2; }\n  if (c === 0x75/* u */) { return 4; }\n  if (c === 0x55/* U */) { return 8; }\n  return 0;\n}\n\nfunction fromDecimalCode(c) {\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  return -1;\n}\n\nfunction simpleEscapeSequence(c) {\n  /* eslint-disable indent */\n  return (c === 0x30/* 0 */) ? '\\x00' :\n        (c === 0x61/* a */) ? '\\x07' :\n        (c === 0x62/* b */) ? '\\x08' :\n        (c === 0x74/* t */) ? '\\x09' :\n        (c === 0x09/* Tab */) ? '\\x09' :\n        (c === 0x6E/* n */) ? '\\x0A' :\n        (c === 0x76/* v */) ? '\\x0B' :\n        (c === 0x66/* f */) ? '\\x0C' :\n        (c === 0x72/* r */) ? '\\x0D' :\n        (c === 0x65/* e */) ? '\\x1B' :\n        (c === 0x20/* Space */) ? ' ' :\n        (c === 0x22/* \" */) ? '\\x22' :\n        (c === 0x2F/* / */) ? '/' :\n        (c === 0x5C/* \\ */) ? '\\x5C' :\n        (c === 0x4E/* N */) ? '\\x85' :\n        (c === 0x5F/* _ */) ? '\\xA0' :\n        (c === 0x4C/* L */) ? '\\u2028' :\n        (c === 0x50/* P */) ? '\\u2029' : '';\n}\n\nfunction charFromCodepoint(c) {\n  if (c <= 0xFFFF) {\n    return String.fromCharCode(c);\n  }\n  // Encode UTF-16 surrogate pair\n  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n  return String.fromCharCode(\n    ((c - 0x010000) >> 10) + 0xD800,\n    ((c - 0x010000) & 0x03FF) + 0xDC00\n  );\n}\n\nvar simpleEscapeCheck = new Array(256); // integer, for fast access\nvar simpleEscapeMap = new Array(256);\nfor (var i = 0; i < 256; i++) {\n  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n  simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\n\n\nfunction State(input, options) {\n  this.input = input;\n\n  this.filename  = options['filename']  || null;\n  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;\n  this.onWarning = options['onWarning'] || null;\n  this.legacy    = options['legacy']    || false;\n  this.json      = options['json']      || false;\n  this.listener  = options['listener']  || null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.typeMap       = this.schema.compiledTypeMap;\n\n  this.length     = input.length;\n  this.position   = 0;\n  this.line       = 0;\n  this.lineStart  = 0;\n  this.lineIndent = 0;\n\n  this.documents = [];\n\n  /*\n  this.version;\n  this.checkLineBreaks;\n  this.tagMap;\n  this.anchorMap;\n  this.tag;\n  this.anchor;\n  this.kind;\n  this.result;*/\n\n}\n\n\nfunction generateError(state, message) {\n  return new YAMLException(\n    message,\n    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));\n}\n\nfunction throwError(state, message) {\n  throw generateError(state, message);\n}\n\nfunction throwWarning(state, message) {\n  if (state.onWarning) {\n    state.onWarning.call(null, generateError(state, message));\n  }\n}\n\n\nvar directiveHandlers = {\n\n  YAML: function handleYamlDirective(state, name, args) {\n\n    var match, major, minor;\n\n    if (state.version !== null) {\n      throwError(state, 'duplication of %YAML directive');\n    }\n\n    if (args.length !== 1) {\n      throwError(state, 'YAML directive accepts exactly one argument');\n    }\n\n    match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n    if (match === null) {\n      throwError(state, 'ill-formed argument of the YAML directive');\n    }\n\n    major = parseInt(match[1], 10);\n    minor = parseInt(match[2], 10);\n\n    if (major !== 1) {\n      throwError(state, 'unacceptable YAML version of the document');\n    }\n\n    state.version = args[0];\n    state.checkLineBreaks = (minor < 2);\n\n    if (minor !== 1 && minor !== 2) {\n      throwWarning(state, 'unsupported YAML version of the document');\n    }\n  },\n\n  TAG: function handleTagDirective(state, name, args) {\n\n    var handle, prefix;\n\n    if (args.length !== 2) {\n      throwError(state, 'TAG directive accepts exactly two arguments');\n    }\n\n    handle = args[0];\n    prefix = args[1];\n\n    if (!PATTERN_TAG_HANDLE.test(handle)) {\n      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n    }\n\n    if (_hasOwnProperty.call(state.tagMap, handle)) {\n      throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n    }\n\n    if (!PATTERN_TAG_URI.test(prefix)) {\n      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n    }\n\n    state.tagMap[handle] = prefix;\n  }\n};\n\n\nfunction captureSegment(state, start, end, checkJson) {\n  var _position, _length, _character, _result;\n\n  if (start < end) {\n    _result = state.input.slice(start, end);\n\n    if (checkJson) {\n      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n        _character = _result.charCodeAt(_position);\n        if (!(_character === 0x09 ||\n              (0x20 <= _character && _character <= 0x10FFFF))) {\n          throwError(state, 'expected valid JSON character');\n        }\n      }\n    } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n      throwError(state, 'the stream contains non-printable characters');\n    }\n\n    state.result += _result;\n  }\n}\n\nfunction mergeMappings(state, destination, source, overridableKeys) {\n  var sourceKeys, key, index, quantity;\n\n  if (!common.isObject(source)) {\n    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n  }\n\n  sourceKeys = Object.keys(source);\n\n  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n    key = sourceKeys[index];\n\n    if (!_hasOwnProperty.call(destination, key)) {\n      destination[key] = source[key];\n      overridableKeys[key] = true;\n    }\n  }\n}\n\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {\n  var index, quantity;\n\n  // The output is a plain object here, so keys can only be strings.\n  // We need to convert keyNode to a string, but doing so can hang the process\n  // (deeply nested arrays that explode exponentially using aliases).\n  if (Array.isArray(keyNode)) {\n    keyNode = Array.prototype.slice.call(keyNode);\n\n    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n      if (Array.isArray(keyNode[index])) {\n        throwError(state, 'nested arrays are not supported inside keys');\n      }\n\n      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n        keyNode[index] = '[object Object]';\n      }\n    }\n  }\n\n  // Avoid code execution in load() via toString property\n  // (still use its own toString for arrays, timestamps,\n  // and whatever user schema extensions happen to have @@toStringTag)\n  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n    keyNode = '[object Object]';\n  }\n\n\n  keyNode = String(keyNode);\n\n  if (_result === null) {\n    _result = {};\n  }\n\n  if (keyTag === 'tag:yaml.org,2002:merge') {\n    if (Array.isArray(valueNode)) {\n      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n        mergeMappings(state, _result, valueNode[index], overridableKeys);\n      }\n    } else {\n      mergeMappings(state, _result, valueNode, overridableKeys);\n    }\n  } else {\n    if (!state.json &&\n        !_hasOwnProperty.call(overridableKeys, keyNode) &&\n        _hasOwnProperty.call(_result, keyNode)) {\n      state.line = startLine || state.line;\n      state.position = startPos || state.position;\n      throwError(state, 'duplicated mapping key');\n    }\n    _result[keyNode] = valueNode;\n    delete overridableKeys[keyNode];\n  }\n\n  return _result;\n}\n\nfunction readLineBreak(state) {\n  var ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x0A/* LF */) {\n    state.position++;\n  } else if (ch === 0x0D/* CR */) {\n    state.position++;\n    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {\n      state.position++;\n    }\n  } else {\n    throwError(state, 'a line break is expected');\n  }\n\n  state.line += 1;\n  state.lineStart = state.position;\n}\n\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n  var lineBreaks = 0,\n      ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    while (is_WHITE_SPACE(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (allowComments && ch === 0x23/* # */) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);\n    }\n\n    if (is_EOL(ch)) {\n      readLineBreak(state);\n\n      ch = state.input.charCodeAt(state.position);\n      lineBreaks++;\n      state.lineIndent = 0;\n\n      while (ch === 0x20/* Space */) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n    throwWarning(state, 'deficient indentation');\n  }\n\n  return lineBreaks;\n}\n\nfunction testDocumentSeparator(state) {\n  var _position = state.position,\n      ch;\n\n  ch = state.input.charCodeAt(_position);\n\n  // Condition state.position === state.lineStart is tested\n  // in parent on each call, for efficiency. No needs to test here again.\n  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&\n      ch === state.input.charCodeAt(_position + 1) &&\n      ch === state.input.charCodeAt(_position + 2)) {\n\n    _position += 3;\n\n    ch = state.input.charCodeAt(_position);\n\n    if (ch === 0 || is_WS_OR_EOL(ch)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction writeFoldedLines(state, count) {\n  if (count === 1) {\n    state.result += ' ';\n  } else if (count > 1) {\n    state.result += common.repeat('\\n', count - 1);\n  }\n}\n\n\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n  var preceding,\n      following,\n      captureStart,\n      captureEnd,\n      hasPendingContent,\n      _line,\n      _lineStart,\n      _lineIndent,\n      _kind = state.kind,\n      _result = state.result,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (is_WS_OR_EOL(ch)      ||\n      is_FLOW_INDICATOR(ch) ||\n      ch === 0x23/* # */    ||\n      ch === 0x26/* & */    ||\n      ch === 0x2A/* * */    ||\n      ch === 0x21/* ! */    ||\n      ch === 0x7C/* | */    ||\n      ch === 0x3E/* > */    ||\n      ch === 0x27/* ' */    ||\n      ch === 0x22/* \" */    ||\n      ch === 0x25/* % */    ||\n      ch === 0x40/* @ */    ||\n      ch === 0x60/* ` */) {\n    return false;\n  }\n\n  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (is_WS_OR_EOL(following) ||\n        withinFlowCollection && is_FLOW_INDICATOR(following)) {\n      return false;\n    }\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  captureStart = captureEnd = state.position;\n  hasPendingContent = false;\n\n  while (ch !== 0) {\n    if (ch === 0x3A/* : */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following) ||\n          withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        break;\n      }\n\n    } else if (ch === 0x23/* # */) {\n      preceding = state.input.charCodeAt(state.position - 1);\n\n      if (is_WS_OR_EOL(preceding)) {\n        break;\n      }\n\n    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||\n               withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n      break;\n\n    } else if (is_EOL(ch)) {\n      _line = state.line;\n      _lineStart = state.lineStart;\n      _lineIndent = state.lineIndent;\n      skipSeparationSpace(state, false, -1);\n\n      if (state.lineIndent >= nodeIndent) {\n        hasPendingContent = true;\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      } else {\n        state.position = captureEnd;\n        state.line = _line;\n        state.lineStart = _lineStart;\n        state.lineIndent = _lineIndent;\n        break;\n      }\n    }\n\n    if (hasPendingContent) {\n      captureSegment(state, captureStart, captureEnd, false);\n      writeFoldedLines(state, state.line - _line);\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n    }\n\n    if (!is_WHITE_SPACE(ch)) {\n      captureEnd = state.position + 1;\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  captureSegment(state, captureStart, captureEnd, false);\n\n  if (state.result) {\n    return true;\n  }\n\n  state.kind = _kind;\n  state.result = _result;\n  return false;\n}\n\nfunction readSingleQuotedScalar(state, nodeIndent) {\n  var ch,\n      captureStart, captureEnd;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x27/* ' */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x27/* ' */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (ch === 0x27/* ' */) {\n        captureStart = state.position;\n        state.position++;\n        captureEnd = state.position;\n      } else {\n        return true;\n      }\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a single quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a single quoted scalar');\n}\n\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n  var captureStart,\n      captureEnd,\n      hexLength,\n      hexResult,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x22/* \" */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x22/* \" */) {\n      captureSegment(state, captureStart, state.position, true);\n      state.position++;\n      return true;\n\n    } else if (ch === 0x5C/* \\ */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (is_EOL(ch)) {\n        skipSeparationSpace(state, false, nodeIndent);\n\n        // TODO: rework to inline fn with no type cast?\n      } else if (ch < 256 && simpleEscapeCheck[ch]) {\n        state.result += simpleEscapeMap[ch];\n        state.position++;\n\n      } else if ((tmp = escapedHexLen(ch)) > 0) {\n        hexLength = tmp;\n        hexResult = 0;\n\n        for (; hexLength > 0; hexLength--) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if ((tmp = fromHexCode(ch)) >= 0) {\n            hexResult = (hexResult << 4) + tmp;\n\n          } else {\n            throwError(state, 'expected hexadecimal character');\n          }\n        }\n\n        state.result += charFromCodepoint(hexResult);\n\n        state.position++;\n\n      } else {\n        throwError(state, 'unknown escape sequence');\n      }\n\n      captureStart = captureEnd = state.position;\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a double quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a double quoted scalar');\n}\n\nfunction readFlowCollection(state, nodeIndent) {\n  var readNext = true,\n      _line,\n      _tag     = state.tag,\n      _result,\n      _anchor  = state.anchor,\n      following,\n      terminator,\n      isPair,\n      isExplicitPair,\n      isMapping,\n      overridableKeys = {},\n      keyNode,\n      keyTag,\n      valueNode,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x5B/* [ */) {\n    terminator = 0x5D;/* ] */\n    isMapping = false;\n    _result = [];\n  } else if (ch === 0x7B/* { */) {\n    terminator = 0x7D;/* } */\n    isMapping = true;\n    _result = {};\n  } else {\n    return false;\n  }\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  while (ch !== 0) {\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === terminator) {\n      state.position++;\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = isMapping ? 'mapping' : 'sequence';\n      state.result = _result;\n      return true;\n    } else if (!readNext) {\n      throwError(state, 'missed comma between flow collection entries');\n    }\n\n    keyTag = keyNode = valueNode = null;\n    isPair = isExplicitPair = false;\n\n    if (ch === 0x3F/* ? */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following)) {\n        isPair = isExplicitPair = true;\n        state.position++;\n        skipSeparationSpace(state, true, nodeIndent);\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n    keyTag = state.tag;\n    keyNode = state.result;\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {\n      isPair = true;\n      ch = state.input.charCodeAt(++state.position);\n      skipSeparationSpace(state, true, nodeIndent);\n      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n      valueNode = state.result;\n    }\n\n    if (isMapping) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);\n    } else if (isPair) {\n      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));\n    } else {\n      _result.push(keyNode);\n    }\n\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x2C/* , */) {\n      readNext = true;\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      readNext = false;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a flow collection');\n}\n\nfunction readBlockScalar(state, nodeIndent) {\n  var captureStart,\n      folding,\n      chomping       = CHOMPING_CLIP,\n      didReadContent = false,\n      detectedIndent = false,\n      textIndent     = nodeIndent,\n      emptyLines     = 0,\n      atMoreIndented = false,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x7C/* | */) {\n    folding = false;\n  } else if (ch === 0x3E/* > */) {\n    folding = true;\n  } else {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n\n  while (ch !== 0) {\n    ch = state.input.charCodeAt(++state.position);\n\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      if (CHOMPING_CLIP === chomping) {\n        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;\n      } else {\n        throwError(state, 'repeat of a chomping mode identifier');\n      }\n\n    } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n      if (tmp === 0) {\n        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n      } else if (!detectedIndent) {\n        textIndent = nodeIndent + tmp - 1;\n        detectedIndent = true;\n      } else {\n        throwError(state, 'repeat of an indentation width identifier');\n      }\n\n    } else {\n      break;\n    }\n  }\n\n  if (is_WHITE_SPACE(ch)) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (is_WHITE_SPACE(ch));\n\n    if (ch === 0x23/* # */) {\n      do { ch = state.input.charCodeAt(++state.position); }\n      while (!is_EOL(ch) && (ch !== 0));\n    }\n  }\n\n  while (ch !== 0) {\n    readLineBreak(state);\n    state.lineIndent = 0;\n\n    ch = state.input.charCodeAt(state.position);\n\n    while ((!detectedIndent || state.lineIndent < textIndent) &&\n           (ch === 0x20/* Space */)) {\n      state.lineIndent++;\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (!detectedIndent && state.lineIndent > textIndent) {\n      textIndent = state.lineIndent;\n    }\n\n    if (is_EOL(ch)) {\n      emptyLines++;\n      continue;\n    }\n\n    // End of the scalar.\n    if (state.lineIndent < textIndent) {\n\n      // Perform the chomping.\n      if (chomping === CHOMPING_KEEP) {\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n      } else if (chomping === CHOMPING_CLIP) {\n        if (didReadContent) { // i.e. only if the scalar is not empty.\n          state.result += '\\n';\n        }\n      }\n\n      // Break this `while` cycle and go to the funciton's epilogue.\n      break;\n    }\n\n    // Folded style: use fancy rules to handle line breaks.\n    if (folding) {\n\n      // Lines starting with white space characters (more-indented lines) are not folded.\n      if (is_WHITE_SPACE(ch)) {\n        atMoreIndented = true;\n        // except for the first content line (cf. Example 8.1)\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n\n      // End of more-indented block.\n      } else if (atMoreIndented) {\n        atMoreIndented = false;\n        state.result += common.repeat('\\n', emptyLines + 1);\n\n      // Just one line break - perceive as the same line.\n      } else if (emptyLines === 0) {\n        if (didReadContent) { // i.e. only if we have already read some scalar content.\n          state.result += ' ';\n        }\n\n      // Several line breaks - perceive as different lines.\n      } else {\n        state.result += common.repeat('\\n', emptyLines);\n      }\n\n    // Literal style: just add exact number of line breaks between content lines.\n    } else {\n      // Keep all line breaks except the header line break.\n      state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n    }\n\n    didReadContent = true;\n    detectedIndent = true;\n    emptyLines = 0;\n    captureStart = state.position;\n\n    while (!is_EOL(ch) && (ch !== 0)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    captureSegment(state, captureStart, state.position, false);\n  }\n\n  return true;\n}\n\nfunction readBlockSequence(state, nodeIndent) {\n  var _line,\n      _tag      = state.tag,\n      _anchor   = state.anchor,\n      _result   = [],\n      following,\n      detected  = false,\n      ch;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n\n    if (ch !== 0x2D/* - */) {\n      break;\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (!is_WS_OR_EOL(following)) {\n      break;\n    }\n\n    detected = true;\n    state.position++;\n\n    if (skipSeparationSpace(state, true, -1)) {\n      if (state.lineIndent <= nodeIndent) {\n        _result.push(null);\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n    _result.push(state.result);\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a sequence entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'sequence';\n    state.result = _result;\n    return true;\n  }\n  return false;\n}\n\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n  var following,\n      allowCompact,\n      _line,\n      _pos,\n      _tag          = state.tag,\n      _anchor       = state.anchor,\n      _result       = {},\n      overridableKeys = {},\n      keyTag        = null,\n      keyNode       = null,\n      valueNode     = null,\n      atExplicitKey = false,\n      detected      = false,\n      ch;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    following = state.input.charCodeAt(state.position + 1);\n    _line = state.line; // Save the current line.\n    _pos = state.position;\n\n    //\n    // Explicit notation case. There are two separate blocks:\n    // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n    //\n    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {\n\n      if (ch === 0x3F/* ? */) {\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n          keyTag = keyNode = valueNode = null;\n        }\n\n        detected = true;\n        atExplicitKey = true;\n        allowCompact = true;\n\n      } else if (atExplicitKey) {\n        // i.e. 0x3A/* : */ === character after the explicit key.\n        atExplicitKey = false;\n        allowCompact = true;\n\n      } else {\n        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n      }\n\n      state.position += 1;\n      ch = following;\n\n    //\n    // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n    //\n    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n\n      if (state.line === _line) {\n        ch = state.input.charCodeAt(state.position);\n\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (ch === 0x3A/* : */) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if (!is_WS_OR_EOL(ch)) {\n            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n          }\n\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n            keyTag = keyNode = valueNode = null;\n          }\n\n          detected = true;\n          atExplicitKey = false;\n          allowCompact = false;\n          keyTag = state.tag;\n          keyNode = state.result;\n\n        } else if (detected) {\n          throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n\n      } else if (detected) {\n        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n\n      } else {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        return true; // Keep the result of `composeNode`.\n      }\n\n    } else {\n      break; // Reading is done. Go to the epilogue.\n    }\n\n    //\n    // Common reading code for both explicit and implicit notations.\n    //\n    if (state.line === _line || state.lineIndent > nodeIndent) {\n      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n        if (atExplicitKey) {\n          keyNode = state.result;\n        } else {\n          valueNode = state.result;\n        }\n      }\n\n      if (!atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);\n        keyTag = keyNode = valueNode = null;\n      }\n\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n    }\n\n    if (state.lineIndent > nodeIndent && (ch !== 0)) {\n      throwError(state, 'bad indentation of a mapping entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  //\n  // Epilogue.\n  //\n\n  // Special case: last mapping's node contains only the key in explicit notation.\n  if (atExplicitKey) {\n    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n  }\n\n  // Expose the resulting mapping.\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'mapping';\n    state.result = _result;\n  }\n\n  return detected;\n}\n\nfunction readTagProperty(state) {\n  var _position,\n      isVerbatim = false,\n      isNamed    = false,\n      tagHandle,\n      tagName,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x21/* ! */) return false;\n\n  if (state.tag !== null) {\n    throwError(state, 'duplication of a tag property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  if (ch === 0x3C/* < */) {\n    isVerbatim = true;\n    ch = state.input.charCodeAt(++state.position);\n\n  } else if (ch === 0x21/* ! */) {\n    isNamed = true;\n    tagHandle = '!!';\n    ch = state.input.charCodeAt(++state.position);\n\n  } else {\n    tagHandle = '!';\n  }\n\n  _position = state.position;\n\n  if (isVerbatim) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (ch !== 0 && ch !== 0x3E/* > */);\n\n    if (state.position < state.length) {\n      tagName = state.input.slice(_position, state.position);\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      throwError(state, 'unexpected end of the stream within a verbatim tag');\n    }\n  } else {\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n\n      if (ch === 0x21/* ! */) {\n        if (!isNamed) {\n          tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n            throwError(state, 'named tag handle cannot contain such characters');\n          }\n\n          isNamed = true;\n          _position = state.position + 1;\n        } else {\n          throwError(state, 'tag suffix cannot contain exclamation marks');\n        }\n      }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    tagName = state.input.slice(_position, state.position);\n\n    if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n      throwError(state, 'tag suffix cannot contain flow indicator characters');\n    }\n  }\n\n  if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n    throwError(state, 'tag name cannot contain such characters: ' + tagName);\n  }\n\n  if (isVerbatim) {\n    state.tag = tagName;\n\n  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {\n    state.tag = state.tagMap[tagHandle] + tagName;\n\n  } else if (tagHandle === '!') {\n    state.tag = '!' + tagName;\n\n  } else if (tagHandle === '!!') {\n    state.tag = 'tag:yaml.org,2002:' + tagName;\n\n  } else {\n    throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n  }\n\n  return true;\n}\n\nfunction readAnchorProperty(state) {\n  var _position,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x26/* & */) return false;\n\n  if (state.anchor !== null) {\n    throwError(state, 'duplication of an anchor property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an anchor node must contain at least one character');\n  }\n\n  state.anchor = state.input.slice(_position, state.position);\n  return true;\n}\n\nfunction readAlias(state) {\n  var _position, alias,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x2A/* * */) return false;\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an alias node must contain at least one character');\n  }\n\n  alias = state.input.slice(_position, state.position);\n\n  if (!_hasOwnProperty.call(state.anchorMap, alias)) {\n    throwError(state, 'unidentified alias \"' + alias + '\"');\n  }\n\n  state.result = state.anchorMap[alias];\n  skipSeparationSpace(state, true, -1);\n  return true;\n}\n\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n  var allowBlockStyles,\n      allowBlockScalars,\n      allowBlockCollections,\n      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent\n      atNewLine  = false,\n      hasContent = false,\n      typeIndex,\n      typeQuantity,\n      type,\n      flowIndent,\n      blockIndent;\n\n  if (state.listener !== null) {\n    state.listener('open', state);\n  }\n\n  state.tag    = null;\n  state.anchor = null;\n  state.kind   = null;\n  state.result = null;\n\n  allowBlockStyles = allowBlockScalars = allowBlockCollections =\n    CONTEXT_BLOCK_OUT === nodeContext ||\n    CONTEXT_BLOCK_IN  === nodeContext;\n\n  if (allowToSeek) {\n    if (skipSeparationSpace(state, true, -1)) {\n      atNewLine = true;\n\n      if (state.lineIndent > parentIndent) {\n        indentStatus = 1;\n      } else if (state.lineIndent === parentIndent) {\n        indentStatus = 0;\n      } else if (state.lineIndent < parentIndent) {\n        indentStatus = -1;\n      }\n    }\n  }\n\n  if (indentStatus === 1) {\n    while (readTagProperty(state) || readAnchorProperty(state)) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n        allowBlockCollections = allowBlockStyles;\n\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      } else {\n        allowBlockCollections = false;\n      }\n    }\n  }\n\n  if (allowBlockCollections) {\n    allowBlockCollections = atNewLine || allowCompact;\n  }\n\n  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n      flowIndent = parentIndent;\n    } else {\n      flowIndent = parentIndent + 1;\n    }\n\n    blockIndent = state.position - state.lineStart;\n\n    if (indentStatus === 1) {\n      if (allowBlockCollections &&\n          (readBlockSequence(state, blockIndent) ||\n           readBlockMapping(state, blockIndent, flowIndent)) ||\n          readFlowCollection(state, flowIndent)) {\n        hasContent = true;\n      } else {\n        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||\n            readSingleQuotedScalar(state, flowIndent) ||\n            readDoubleQuotedScalar(state, flowIndent)) {\n          hasContent = true;\n\n        } else if (readAlias(state)) {\n          hasContent = true;\n\n          if (state.tag !== null || state.anchor !== null) {\n            throwError(state, 'alias node should not have any properties');\n          }\n\n        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n          hasContent = true;\n\n          if (state.tag === null) {\n            state.tag = '?';\n          }\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else if (indentStatus === 0) {\n      // Special case: block sequences are allowed to have same indentation level as the parent.\n      // http://www.yaml.org/spec/1.2/spec.html#id2799784\n      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n    }\n  }\n\n  if (state.tag !== null && state.tag !== '!') {\n    if (state.tag === '?') {\n      // Implicit resolving is not allowed for non-scalar types, and '?'\n      // non-specific tag is only automatically assigned to plain scalars.\n      //\n      // We only need to check kind conformity in case user explicitly assigns '?'\n      // tag, for example like this: \"!<?> [0]\"\n      //\n      if (state.result !== null && state.kind !== 'scalar') {\n        throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n      }\n\n      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n        type = state.implicitTypes[typeIndex];\n\n        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched\n          state.result = type.construct(state.result);\n          state.tag = type.tag;\n          if (state.anchor !== null) {\n            state.anchorMap[state.anchor] = state.result;\n          }\n          break;\n        }\n      }\n    } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n      type = state.typeMap[state.kind || 'fallback'][state.tag];\n\n      if (state.result !== null && type.kind !== state.kind) {\n        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n      }\n\n      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched\n        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n      } else {\n        state.result = type.construct(state.result);\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else {\n      throwError(state, 'unknown tag !<' + state.tag + '>');\n    }\n  }\n\n  if (state.listener !== null) {\n    state.listener('close', state);\n  }\n  return state.tag !== null ||  state.anchor !== null || hasContent;\n}\n\nfunction readDocument(state) {\n  var documentStart = state.position,\n      _position,\n      directiveName,\n      directiveArgs,\n      hasDirectives = false,\n      ch;\n\n  state.version = null;\n  state.checkLineBreaks = state.legacy;\n  state.tagMap = {};\n  state.anchorMap = {};\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (state.lineIndent > 0 || ch !== 0x25/* % */) {\n      break;\n    }\n\n    hasDirectives = true;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    directiveName = state.input.slice(_position, state.position);\n    directiveArgs = [];\n\n    if (directiveName.length < 1) {\n      throwError(state, 'directive name must not be less than one character in length');\n    }\n\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (ch === 0x23/* # */) {\n        do { ch = state.input.charCodeAt(++state.position); }\n        while (ch !== 0 && !is_EOL(ch));\n        break;\n      }\n\n      if (is_EOL(ch)) break;\n\n      _position = state.position;\n\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      directiveArgs.push(state.input.slice(_position, state.position));\n    }\n\n    if (ch !== 0) readLineBreak(state);\n\n    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {\n      directiveHandlers[directiveName](state, directiveName, directiveArgs);\n    } else {\n      throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n    }\n  }\n\n  skipSeparationSpace(state, true, -1);\n\n  if (state.lineIndent === 0 &&\n      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {\n    state.position += 3;\n    skipSeparationSpace(state, true, -1);\n\n  } else if (hasDirectives) {\n    throwError(state, 'directives end mark is expected');\n  }\n\n  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n  skipSeparationSpace(state, true, -1);\n\n  if (state.checkLineBreaks &&\n      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n    throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n  }\n\n  state.documents.push(state.result);\n\n  if (state.position === state.lineStart && testDocumentSeparator(state)) {\n\n    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n    }\n    return;\n  }\n\n  if (state.position < (state.length - 1)) {\n    throwError(state, 'end of the stream or a document separator is expected');\n  } else {\n    return;\n  }\n}\n\n\nfunction loadDocuments(input, options) {\n  input = String(input);\n  options = options || {};\n\n  if (input.length !== 0) {\n\n    // Add tailing `\\n` if not exists\n    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&\n        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {\n      input += '\\n';\n    }\n\n    // Strip BOM\n    if (input.charCodeAt(0) === 0xFEFF) {\n      input = input.slice(1);\n    }\n  }\n\n  var state = new State(input, options);\n\n  var nullpos = input.indexOf('\\0');\n\n  if (nullpos !== -1) {\n    state.position = nullpos;\n    throwError(state, 'null byte is not allowed in input');\n  }\n\n  // Use 0 as string terminator. That significantly simplifies bounds check.\n  state.input += '\\0';\n\n  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {\n    state.lineIndent += 1;\n    state.position += 1;\n  }\n\n  while (state.position < (state.length - 1)) {\n    readDocument(state);\n  }\n\n  return state.documents;\n}\n\n\nfunction loadAll(input, iterator, options) {\n  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  var documents = loadDocuments(input, options);\n\n  if (typeof iterator !== 'function') {\n    return documents;\n  }\n\n  for (var index = 0, length = documents.length; index < length; index += 1) {\n    iterator(documents[index]);\n  }\n}\n\n\nfunction load(input, options) {\n  var documents = loadDocuments(input, options);\n\n  if (documents.length === 0) {\n    /*eslint-disable no-undefined*/\n    return undefined;\n  } else if (documents.length === 1) {\n    return documents[0];\n  }\n  throw new YAMLException('expected a single document in the stream, but found more');\n}\n\n\nfunction safeLoadAll(input, iterator, options) {\n  if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n}\n\n\nfunction safeLoad(input, options) {\n  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n}\n\n\nmodule.exports.loadAll     = loadAll;\nmodule.exports.load        = load;\nmodule.exports.safeLoadAll = safeLoadAll;\nmodule.exports.safeLoad    = safeLoad;\n","'use strict';\n\n/*eslint-disable no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar DEFAULT_FULL_SCHEMA = require('./schema/default_full');\nvar DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n\nvar _toString       = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_EQUALS               = 0x3D; /* = */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (map === null) return {};\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\nfunction State(options) {\n  this.schema        = options['schema'] || DEFAULT_FULL_SCHEMA;\n  this.indent        = Math.max(1, (options['indent'] || 2));\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid   = options['skipInvalid'] || false;\n  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys      = options['sortKeys'] || false;\n  this.lineWidth     = options['lineWidth'] || 80;\n  this.noRefs        = options['noRefs'] || false;\n  this.noCompatMode  = options['noCompatMode'] || false;\n  this.condenseFlow  = options['condenseFlow'] || false;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n}\n\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isn’t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n  return  (0x00020 <= c && c <= 0x00007E)\n      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)\n      ||  (0x10000 <= c && c <= 0x10FFFF);\n}\n\n// [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// [24] b-line-feed       ::=     #xA    /* LF */\n// [25] b-carriage-return ::=     #xD    /* CR */\n// [3]  c-byte-order-mark ::=     #xFEFF\nfunction isNsChar(c) {\n  return isPrintable(c) && !isWhitespace(c)\n    // byte-order-mark\n    && c !== 0xFEFF\n    // b-char\n    && c !== CHAR_CARRIAGE_RETURN\n    && c !== CHAR_LINE_FEED;\n}\n\n// Simplified test for values allowed after the first character in plain style.\nfunction isPlainSafe(c, prev) {\n  // Uses a subset of nb-char - c-flow-indicator - \":\" - \"#\"\n  // where nb-char ::= c-printable - b-char - c-byte-order-mark.\n  return isPrintable(c) && c !== 0xFEFF\n    // - c-flow-indicator\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // - \":\" - \"#\"\n    // /* An ns-char preceding */ \"#\"\n    && c !== CHAR_COLON\n    && ((c !== CHAR_SHARP) || (prev && isNsChar(prev)));\n}\n\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  return isPrintable(c) && c !== 0xFEFF\n    && !isWhitespace(c) // - s-white\n    // - (c-indicator ::=\n    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”\n    && c !== CHAR_MINUS\n    && c !== CHAR_QUESTION\n    && c !== CHAR_COLON\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “\"”\n    && c !== CHAR_SHARP\n    && c !== CHAR_AMPERSAND\n    && c !== CHAR_ASTERISK\n    && c !== CHAR_EXCLAMATION\n    && c !== CHAR_VERTICAL_LINE\n    && c !== CHAR_EQUALS\n    && c !== CHAR_GREATER_THAN\n    && c !== CHAR_SINGLE_QUOTE\n    && c !== CHAR_DOUBLE_QUOTE\n    // | “%” | “@” | “`”)\n    && c !== CHAR_PERCENT\n    && c !== CHAR_COMMERCIAL_AT\n    && c !== CHAR_GRAVE_ACCENT;\n}\n\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN   = 1,\n    STYLE_SINGLE  = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED  = 4,\n    STYLE_DOUBLE  = 5;\n\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {\n  var i;\n  var char, prev_char;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n  var plain = isPlainSafeFirst(string.charCodeAt(0))\n          && !isWhitespace(string.charCodeAt(string.length - 1));\n\n  if (singleLineOnly) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n      plain = plain && isPlainSafe(char, prev_char);\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true;\n        // Check if any line can be folded.\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine ||\n            // Foldable line = too long, and not more-indented.\n            (i - previousLineBreak - 1 > lineWidth &&\n             string[previousLineBreak + 1] !== ' ');\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n      plain = plain && isPlainSafe(char, prev_char);\n    }\n    // in case the end is missing a \\n\n    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n      (i - previousLineBreak - 1 > lineWidth &&\n       string[previousLineBreak + 1] !== ' '));\n  }\n  // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    return plain && !testAmbiguousType(string)\n      ? STYLE_PLAIN : STYLE_SINGLE;\n  }\n  // Edge case: block indentation indicator can only have one digit.\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  }\n  // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n}\n\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    • No ending newline => unaffected; already using strip \"-\" chomping.\n//    • Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey) {\n  state.dump = (function () {\n    if (string.length === 0) {\n      return \"''\";\n    }\n    if (!state.noCompatMode &&\n        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {\n      return \"'\" + string + \"'\";\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n    var lineWidth = state.lineWidth === -1\n      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\n    var singleLineOnly = iskey\n      // No block styles in flow mode.\n      || (state.flowLevel > -1 && level >= state.flowLevel);\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {\n      case STYLE_PLAIN:\n        return string;\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(string, indent));\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string, lineWidth) + '\"';\n      default:\n        throw new YAMLException('impossible error: invalid scalar style');\n    }\n  }());\n}\n\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n  // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n  var clip =          string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : (clip ? '' : '-');\n\n  return indentIndicator + chomp + '\\n';\n}\n\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n}\n\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g;\n\n  // first line (possibly an empty line)\n  var result = (function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }());\n  // If we haven't reached the first content line yet, don't add an extra \\n.\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented;\n\n  // rest of the lines\n  var match;\n  while ((match = lineRe.exec(string))) {\n    var prefix = match[1], line = match[2];\n    moreIndented = (line[0] === ' ');\n    result += prefix\n      + (!prevMoreIndented && !moreIndented && line !== ''\n        ? '\\n' : '')\n      + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n}\n\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line;\n\n  // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n  var match;\n  // start is an inclusive index. end, curr, and next are exclusive.\n  var start = 0, end, curr = 0, next = 0;\n  var result = '';\n\n  // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n  while ((match = breakRe.exec(line))) {\n    next = match.index;\n    // maintain invariant: curr - start <= width\n    if (next - start > width) {\n      end = (curr > start) ? curr : next; // derive end <= length-2\n      result += '\\n' + line.slice(start, end);\n      // skip the space that was output as \\n\n      start = end + 1;                    // derive start <= length-1\n    }\n    curr = next;\n  }\n\n  // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n  result += '\\n';\n  // Insert a break if the remainder is too long and there is a break available.\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n}\n\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n  var result = '';\n  var char, nextChar;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; i++) {\n    char = string.charCodeAt(i);\n    // Check for surrogate pairs (reference Unicode 3.0 section \"3.7 Surrogates\").\n    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {\n      nextChar = string.charCodeAt(i + 1);\n      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {\n        // Combine the surrogate pair and store it escaped.\n        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);\n        // Advance index one extra since we already used that char here.\n        i++; continue;\n      }\n    }\n    escapeSeq = ESCAPE_SEQUENCES[char];\n    result += !escapeSeq && isPrintable(char)\n      ? string[i]\n      : escapeSeq || encodeHex(char);\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level, object[index], false, false)) {\n      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level + 1, object[index], true, true)) {\n      if (!compact || index !== 0) {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n    pairBuffer = '';\n    if (index !== 0) pairBuffer += ', ';\n\n    if (state.condenseFlow) pairBuffer += '\"';\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new YAMLException('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || index !== 0) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (state.tag !== null && state.tag !== '?') ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      state.tag = explicit ? type.tag : '?';\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n\n  if (block) {\n    block = (state.flowLevel < 0 || state.flowLevel > level);\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if (type === '[object Object]') {\n      if (block && (Object.keys(state.dump).length !== 0)) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;\n      if (block && (state.dump.length !== 0)) {\n        writeBlockSequence(state, arrayLevel, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, arrayLevel, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey);\n      }\n    } else {\n      if (state.skipInvalid) return false;\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      state.dump = '!<' + state.tag + '> ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList,\n      index,\n      length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n\n  var state = new State(options);\n\n  if (!state.noRefs) getDuplicateReferences(input, state);\n\n  if (writeNode(state, 0, input, true, true)) return state.dump + '\\n';\n\n  return '';\n}\n\nfunction safeDump(input, options) {\n  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n}\n\nmodule.exports.dump     = dump;\nmodule.exports.safeDump = safeDump;\n","'use strict';\n\n\nvar loader = require('./js-yaml/loader');\nvar dumper = require('./js-yaml/dumper');\n\n\nfunction deprecated(name) {\n  return function () {\n    throw new Error('Function ' + name + ' is deprecated and cannot be used.');\n  };\n}\n\n\nmodule.exports.Type                = require('./js-yaml/type');\nmodule.exports.Schema              = require('./js-yaml/schema');\nmodule.exports.FAILSAFE_SCHEMA     = require('./js-yaml/schema/failsafe');\nmodule.exports.JSON_SCHEMA         = require('./js-yaml/schema/json');\nmodule.exports.CORE_SCHEMA         = require('./js-yaml/schema/core');\nmodule.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');\nmodule.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');\nmodule.exports.load                = loader.load;\nmodule.exports.loadAll             = loader.loadAll;\nmodule.exports.safeLoad            = loader.safeLoad;\nmodule.exports.safeLoadAll         = loader.safeLoadAll;\nmodule.exports.dump                = dumper.dump;\nmodule.exports.safeDump            = dumper.safeDump;\nmodule.exports.YAMLException       = require('./js-yaml/exception');\n\n// Deprecated schema names from JS-YAML 2.0.x\nmodule.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');\nmodule.exports.SAFE_SCHEMA    = require('./js-yaml/schema/default_safe');\nmodule.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');\n\n// Deprecated functions from JS-YAML 1.x.x\nmodule.exports.scan           = deprecated('scan');\nmodule.exports.parse          = deprecated('parse');\nmodule.exports.compose        = deprecated('compose');\nmodule.exports.addConstructor = deprecated('addConstructor');\n","'use strict';\n\n\nvar yaml = require('./lib/js-yaml.js');\n\n\nmodule.exports = yaml;\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/** Convert a directives first line and content to its structural components\n *\n * The code is adapted from: myst_parser/parse_directives.py\n * and is common for all directives\n */\n\nimport yaml from \"js-yaml\"\nimport type StateCore from \"markdown-it/lib/rules_core/state_core\"\nimport type Token from \"markdown-it/lib/token\"\nimport { OptionSpecConverter } from \"./options\"\nimport { nestedCoreParse } from \"../nestedCoreParse\"\n\n/** token specification for a directive */\nexport class DirectiveToken implements Token {\n  public type = \"directive\"\n  public tag = \"\"\n  public attrs = null\n  public nesting = 0 as 1 | 0 | -1\n  public level = 0\n  public children = null\n  public markup = \"\"\n  public block = true\n  public hidden = false\n  public info: string\n  public meta: { arg: string }\n  public content: string\n  public map: [number, number]\n  constructor(name: string, arg: string, content: string, map: [number, number]) {\n    this.info = name\n    this.meta = { arg }\n    this.content = content\n    this.map = map\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  attrIndex(name: string): number {\n    return -1\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  attrPush(attrData: [string, string]): void {\n    throw new Error(\"not implemented\")\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  attrSet(name: string, value: string): void {\n    throw new Error(\"not implemented\")\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  attrGet(name: string): null {\n    return null\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  attrJoin(name: string, value: string): void {\n    throw new Error(\"not implemented\")\n  }\n}\n\n/** Data required to parse a directive first line and content to its structure */\nexport interface IDirectiveSpec {\n  /** number of required arguments */\n  required_arguments?: number\n  /** number of optional arguments */\n  optional_arguments?: number\n  /** indicating if the final argument may contain whitespace */\n  final_argument_whitespace?: boolean\n  /** if body content is allowed */\n  has_content?: boolean\n  /** mapping known option names to conversion functions */\n  option_spec?: Record<string, OptionSpecConverter>\n  /** If true, do not attempt to validate/convert options. */\n  rawOptions?: boolean\n}\n\n/** A class to define a single directive */\nexport class Directive implements IDirectiveSpec {\n  public required_arguments = 0\n  public optional_arguments = 0\n  public final_argument_whitespace = false\n  public has_content = false\n  public option_spec = {}\n  public rawOptions = false\n  public state: StateCore\n  constructor(state: StateCore) {\n    this.state = state\n  }\n  /** Convert the directive data to tokens */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  run(data: IDirectiveData): Token[] {\n    return []\n  }\n  assert(test: boolean, msg: string): void {\n    if (!test) {\n      throw new Error(msg)\n    }\n  }\n  /** throw error is no body content parsed. */\n  assert_has_content(data: IDirectiveData): void {\n    if (!data.body) {\n      throw new Error(\"Content block expected, but none found.\")\n    }\n  }\n  /** Create a single token */\n  createToken(\n    type: string,\n    tag: string,\n    nesting: Token.Nesting,\n    optional?: {\n      content?: string\n      level?: number\n      map?: null | [number, number]\n      meta?: any\n      info?: string\n      block?: boolean\n      children?: Token[]\n    }\n  ): Token {\n    const token = new this.state.Token(type, tag, nesting)\n    if (optional?.content !== undefined) {\n      token.content = optional.content\n    }\n    if (optional?.level !== undefined) {\n      token.level = optional.level\n    }\n    if (optional?.map !== undefined) {\n      token.map = optional.map\n    }\n    if (optional?.block !== undefined) {\n      token.block = optional.block\n    }\n    if (optional?.info !== undefined) {\n      token.info = optional.info\n    }\n    if (optional?.meta !== undefined) {\n      token.meta = optional.meta\n    }\n    if (optional?.children !== undefined) {\n      token.children = optional.children\n    }\n    return token\n  }\n  /** parse block of text to tokens (does not run inline parse) */\n  nestedParse(block: string, initLine: number): Token[] {\n    return nestedCoreParse(\n      this.state.md,\n      \"run_directives\",\n      block,\n      this.state.env,\n      initLine,\n      true\n    )\n  }\n}\n\n/** Data structure of a directive */\nexport interface IDirectiveData<T extends string = string> {\n  map: [number, number]\n  args: string[]\n  options: Record<T, any>\n  body: string\n  bodyMap: [number, number]\n}\n\n/** Raise on parsing/validation error. */\nexport class DirectiveParsingError extends Error {\n  name = \"DirectiveParsingError\"\n}\n\n/**\n * This function contains the logic to take the first line of a directive,\n * and the content, and turn it into the three core components:\n * arguments (list), options (key: value mapping), and body (text).\n */\nexport default function directiveToData(\n  token: Token,\n  directive: IDirectiveSpec\n): IDirectiveData {\n  const firstLine = token.meta.arg || \"\"\n  const content = token.content\n  let body = content.trim() ? content.split(/\\r?\\n/) : []\n  let bodyOffset = 0\n  let options = {}\n  if (Object.keys(directive.option_spec || {}) || directive.rawOptions) {\n    ;[body, options, bodyOffset] = parseDirectiveOptions(body, directive)\n  }\n  let args: string[] = []\n  if (\n    !directive.required_arguments &&\n    !directive.optional_arguments &&\n    !Object.keys(options).length\n  ) {\n    if (firstLine) {\n      bodyOffset = 0\n      body = [firstLine].concat(body)\n    }\n  } else {\n    args = parseDirectiveArguments(firstLine, directive)\n  }\n  // remove first line of body if blank, to allow space between the options and the content\n  if (body.length && !body[0].trim()) {\n    body.shift()\n    bodyOffset++\n  }\n  // check for body content\n  if (body.length && !directive.has_content) {\n    throw new DirectiveParsingError(\"Has content but content not allowed\")\n  }\n  return {\n    map: token.map ? token.map : [0, 0],\n    args,\n    options,\n    body: body.join(\"\\n\"),\n    bodyMap: token.map\n      ? [\n          body.length > 0 ? token.map[0] + bodyOffset : token.map[1],\n          body.length > 0 ? token.map[1] - 1 : token.map[1]\n        ]\n      : [0, 0]\n  }\n}\n\nfunction parseDirectiveOptions(\n  content: string[],\n  fullSpec: IDirectiveSpec\n): [string[], { [key: string]: any }, number] {\n  // instantiate options\n  let bodyOffset = 1\n  let options: { [key: string]: any } = {}\n  let yamlBlock: null | string[] = null\n\n  // TODO allow for indented content (I can't remember why this was needed?)\n\n  if (content.length && content[0].startsWith(\"---\")) {\n    // options contained in YAML block, ending with '---'\n    bodyOffset++\n    const newContent: string[] = []\n    yamlBlock = []\n    let foundDivider = false\n    for (const line of content.slice(1)) {\n      if (line.startsWith(\"---\")) {\n        bodyOffset++\n        foundDivider = true\n        continue\n      }\n      if (foundDivider) {\n        newContent.push(line)\n      } else {\n        bodyOffset++\n        yamlBlock.push(line)\n      }\n    }\n    content = newContent\n  } else if (content.length && content[0].startsWith(\":\")) {\n    const newContent: string[] = []\n    yamlBlock = []\n    let foundDivider = false\n    for (const line of content) {\n      if (!foundDivider && !line.startsWith(\":\")) {\n        foundDivider = true\n        newContent.push(line)\n        continue\n      }\n      if (foundDivider) {\n        newContent.push(line)\n      } else {\n        bodyOffset++\n        yamlBlock.push(line.slice(1))\n      }\n    }\n    content = newContent\n  }\n\n  if (yamlBlock !== null) {\n    try {\n      const output = yaml.load(yamlBlock.join(\"\\n\"))\n      if (output !== null && typeof output === \"object\") {\n        options = output\n      } else {\n        throw new DirectiveParsingError(`not dict: ${output}`)\n      }\n    } catch (error) {\n      throw new DirectiveParsingError(`Invalid options YAML: ${error}`)\n    }\n  }\n\n  if (fullSpec.rawOptions) {\n    return [content, options, bodyOffset]\n  }\n\n  for (const [name, value] of Object.entries(options)) {\n    const convertor = fullSpec.option_spec ? fullSpec.option_spec[name] : null\n    if (!convertor) {\n      throw new DirectiveParsingError(`Unknown option: ${name}`)\n    }\n    let converted_value = value\n    if (value === null || value === false) {\n      converted_value = \"\"\n    }\n    try {\n      // In docutils all values are simply read as strings,\n      // but loading with YAML these can be converted to other types, so we convert them back first\n      // TODO check that it is sufficient to simply do this conversion, or if there is a better way\n      converted_value = convertor(`${converted_value || \"\"}`)\n    } catch (error) {\n      throw new DirectiveParsingError(\n        `Invalid option value: (option: '${name}'; value: ${value})\\n${error}`\n      )\n    }\n    options[name] = converted_value\n  }\n\n  return [content, options, bodyOffset]\n}\n\nfunction parseDirectiveArguments(\n  firstLine: string,\n  fullSpec: IDirectiveSpec\n): string[] {\n  let args = firstLine.trim() ? firstLine.trim()?.split(/\\s+/) : []\n  const totalArgs =\n    (fullSpec.required_arguments || 0) + (fullSpec.optional_arguments || 0)\n  if (args.length < (fullSpec.required_arguments || 0)) {\n    throw new DirectiveParsingError(\n      `${fullSpec.required_arguments} argument(s) required, ${args.length} supplied`\n    )\n  } else if (args.length > totalArgs) {\n    if (fullSpec.final_argument_whitespace) {\n      // note split limit does not work the same as in python\n      const arr = firstLine.split(/\\s+/)\n      args = arr.splice(0, totalArgs - 1)\n      // TODO is it ok that we effectively replace all whitespace with single spaces?\n      args.push(arr.join(\" \"))\n    } else {\n      throw new DirectiveParsingError(\n        `maximum ${totalArgs} argument(s) allowed, ${args.length} supplied`\n      )\n    }\n  }\n  return args\n}\n","import type MarkdownIt from \"markdown-it\"\nimport type Token from \"markdown-it/lib/token\"\n\n/** Perform a nested parse upto and including a particular ruleName\n *\n * The main use for this function is to perform nested parses\n * upto but not including inline parsing.\n */\nexport function nestedCoreParse(\n  md: MarkdownIt,\n  pluginRuleName: string,\n  src: string,\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any\n  env: any,\n  initLine: number,\n  includeRule = true\n): Token[] {\n  // disable all core rules after pluginRuleName\n  const tempDisabledCore: string[] = []\n  // TODO __rules__ is currently not exposed in typescript, but is the only way to get the rule names,\n  // since md.core.ruler.getRules('') only returns the rule functions\n  // we should upstream a getRuleNames() function or similar\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore TS2339\n  for (const rule of [...md.core.ruler.__rules__].reverse()) {\n    if (rule.name === pluginRuleName) {\n      if (!includeRule) {\n        tempDisabledCore.push(rule.name)\n      }\n      break\n    }\n    if (rule.name) {\n      tempDisabledCore.push(rule.name)\n    }\n  }\n\n  md.core.ruler.disable(tempDisabledCore)\n\n  let tokens = []\n  try {\n    tokens = md.parse(src, env)\n  } finally {\n    md.core.ruler.enable(tempDisabledCore)\n  }\n  for (const token of tokens) {\n    token.map =\n      token.map !== null\n        ? [token.map[0] + initLine, token.map[1] + initLine]\n        : token.map\n  }\n  return tokens\n}\n","import type MarkdownIt from \"markdown-it/lib\"\nimport type StateCore from \"markdown-it/lib/rules_core/state_core\"\nimport directiveToData, { Directive } from \"./main\"\nimport { IOptions } from \"./types\"\n\nexport default function directivePlugin(md: MarkdownIt, options: IOptions): void {\n  let after = options.directivesAfter || \"block\"\n  if (options.replaceFences ?? true) {\n    md.core.ruler.after(after, \"fence_to_directive\", replaceFences)\n    after = \"fence_to_directive\"\n  }\n  md.core.ruler.after(after, \"run_directives\", runDirectives(options.directives || {}))\n\n  // fallback renderer for unhandled directives\n  md.renderer.rules[\"directive\"] = (tokens, idx) => {\n    const token = tokens[idx]\n    return `<aside class=\"directive-unhandled\">\\n<header><mark>${token.info}</mark><code> ${token.meta.arg}</code></header>\\n<pre>${token.content}</pre></aside>\\n`\n  }\n  md.renderer.rules[\"directive_error\"] = (tokens, idx) => {\n    const token = tokens[idx]\n    let content = \"\"\n    if (token.content) {\n      content = `\\n---\\n${token.content}`\n    }\n    return `<aside class=\"directive-error\">\\n<header><mark>${token.info}</mark><code> ${token.meta.arg}</code></header>\\n<pre>${token.meta.error_name}:\\n${token.meta.error_message}\\n${content}</pre></aside>\\n`\n  }\n}\n\n/** Convert fences identified as directives to `directive` tokens */\nfunction replaceFences(state: StateCore): boolean {\n  for (const token of state.tokens) {\n    if (token.type === \"fence\") {\n      const match = token.info.match(/^\\{([^\\s}]+)\\}\\s*(.*)$/)\n      if (match) {\n        if (token.info === \"mermaid\")\n          continue\n        token.type = \"directive\"\n        token.info = match[1]\n        token.meta = { arg: match[2] }\n      }\n    }\n  }\n  return true\n}\n\n/** Run all directives, replacing the original token */\nfunction runDirectives(directives: {\n  [key: string]: typeof Directive\n}): (state: StateCore) => boolean {\n  function func(state: StateCore): boolean {\n    const finalTokens = []\n    for (const token of state.tokens) {\n      // TODO directive name translations\n      if (token.type === \"directive\" && token.info in directives) {\n        try {\n          const directive = new directives[token.info](state)\n          const data = directiveToData(token, directive)\n          const newTokens = directive.run(data)\n          finalTokens.push(...newTokens)\n        } catch (err) {\n          const errorToken = new state.Token(\"directive_error\", \"\", 0)\n          errorToken.content = token.content\n          errorToken.info = token.info\n          errorToken.meta = token.meta\n          errorToken.map = token.map\n          errorToken.meta.error_message = (err as Error).message\n          errorToken.meta.error_name = (err as Error).name\n          finalTokens.push(errorToken)\n        }\n      } else {\n        finalTokens.push(token)\n      }\n    }\n    state.tokens = finalTokens\n    return true\n  }\n  return func\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/** Functions for converting and validating directive options\n *\n * Primarily adapted from: docutils/docutils/parsers/rst/directives/__init__.py\n */\n\n/**\n * Normalize a string to HTML4 id\n *\n * Adapted from docutils/nodes.py::make_id,\n * it should be noted that in HTML5 the only requirement is no whitespace.\n * */\nexport function make_id(name: string): string {\n  // TODO make more complete\n  return name\n    .toLowerCase()\n    .split(/\\s+/)\n    .join(\"-\")\n    .replace(/[^a-z0-9]+/, \"-\")\n    .replace(/^[-0-9]+|-+$/, \"\")\n}\n\n/** convert and validate an option value */\nexport type OptionSpecConverter = (value: string, options?: any) => any\n\n/** Error to throw when an option is invalid. */\nexport class OptionSpecError extends Error {\n  name = \"OptionSpecError\"\n}\n\n/** Leave value unchanged */\nexport const unchanged: OptionSpecConverter = (value: string): string => value\n\n/** Leave value unchanged, but assert non-empty string */\nexport const unchanged_required: OptionSpecConverter = (value: string): string => {\n  if (!value) {\n    throw new OptionSpecError(\"Argument required but none supplied\")\n  }\n  return value\n}\n\n/** A flag option (no argument) */\nexport const flag: OptionSpecConverter = (value: string): null => {\n  if (value.trim()) {\n    throw new OptionSpecError(`No argument is allowed: \"${value}\" supplied`)\n  }\n  return null\n}\n\n/** Split values by whitespace and normalize to HTML4 id */\nexport const class_option: OptionSpecConverter = (value: string): string[] => {\n  return `${value || \"\"}`.split(/\\s+/).map(name => make_id(name))\n}\n\n/** Check for an integer argument and convert */\nexport function int(argument: string): number {\n  if (!argument) {\n    throw new OptionSpecError(\"Value is not set\")\n  }\n  const value = Number.parseFloat(argument)\n  if (Number.isNaN(value) || !Number.isInteger(value)) {\n    throw new OptionSpecError(`Value \"${argument}\" is not an integer`)\n  }\n  return value\n}\n\n/** Check for a non-negative integer argument and convert */\nexport function nonnegative_int(argument: string): number {\n  const value = int(argument)\n  if (value < 0) {\n    throw new OptionSpecError(`Value \"${argument}\" must be positive or zero`)\n  }\n  return value\n}\n\n/** A non-negative integer or null. */\nexport const optional_int: OptionSpecConverter = (value: string): null | number => {\n  if (!value) {\n    return null\n  }\n  return nonnegative_int(value)\n}\n\n/** Check for an integer percentage value with optional percent sign. */\nexport const percentage: OptionSpecConverter = (value: string): number => {\n  value = `${value || \"\"}`.replace(/\\s+%$/, \"\")\n  return nonnegative_int(value)\n}\n\n/** Check for a positive argument of one of the units and return a\n    normalized string of the form \"<value><unit>\" (without space in\n    between).\n*/\nfunction get_measure(argument: string, units: string[]): string {\n  const regex = new RegExp(`^(?<number>[0-9.]+)\\\\s*(?<units>${units.join(\"|\")})$`)\n  const match = regex.exec(argument)\n  if (!match || !match.groups) {\n    throw new OptionSpecError(\n      `not a positive measure of one of the following units: ${units.join(\"|\")}`\n    )\n  }\n  return match.groups.number + match.groups.units\n}\n\nconst length_units = [\"em\", \"ex\", \"px\", \"in\", \"cm\", \"mm\", \"pt\", \"pc\"]\n\n/** Check for a positive argument of a length unit, allowing for no unit. */\nexport const length_or_unitless: OptionSpecConverter = (value: string): string => {\n  return get_measure(value, [...length_units, \"\"])\n}\n\n/**\nReturn normalized string of a length or percentage unit.\n\nAdd <default> if there is no unit. Raise ValueError if the argument is not\na positive measure of one of the valid CSS units (or without unit).\n\n>>> length_or_percentage_or_unitless('3 pt')\n'3pt'\n>>> length_or_percentage_or_unitless('3%', 'em')\n'3%'\n>>> length_or_percentage_or_unitless('3')\n'3'\n>>> length_or_percentage_or_unitless('3', 'px')\n'3px'\n\n*/\nexport const length_or_percentage_or_unitless: OptionSpecConverter = (\n  argument: string,\n  defaultUnit = \"\"\n): string => {\n  try {\n    return get_measure(argument, [...length_units, \"%\"])\n  } catch {\n    return length_or_unitless(argument) + defaultUnit\n  }\n}\n\nexport const length_or_percentage_or_unitless_figure: OptionSpecConverter = (\n  argument: string,\n  defaultUnit = \"\"\n): string => {\n  if (argument.toLowerCase() === \"image\") {\n    return \"image\"\n  }\n  return length_or_percentage_or_unitless(argument, defaultUnit)\n}\n\n/** Create an option that asserts the (lower-cased & trimmed) value is a member of a choice set. */\nexport function create_choice(choices: string[]): OptionSpecConverter {\n  return (argument: string): string => {\n    argument = argument.toLowerCase().trim()\n    if (choices.includes(argument)) {\n      return argument\n    }\n    throw new OptionSpecError(`must be in: ${choices.join(\"|\")}`)\n  }\n}\n\n/** Return the URI argument with unescaped whitespace removed. */\nexport const uri: OptionSpecConverter = (value: string): string => {\n  // TODO implement whitespace removal\n  return value\n}\n","/** Directives for creating admonitions, also known as call-outs,\n * for including side content without significantly interrupting the document flow.\n */\nimport type Token from \"markdown-it/lib/token\"\nimport { class_option, unchanged } from \"./options\"\nimport { Directive, IDirectiveData } from \"./main\"\n\n/** Directives for admonition boxes.\n *\n * Apdapted from: docutils/docutils/parsers/rst/directives/admonitions.py\n */\nclass BaseAdmonition extends Directive {\n  public final_argument_whitespace = true\n  public has_content = true\n  public option_spec = {\n    class: class_option,\n    // TODO handle name option\n    name: unchanged\n  }\n  public title = \"\"\n  run(data: IDirectiveData<keyof BaseAdmonition[\"option_spec\"]>): Token[] {\n    const newTokens: Token[] = []\n\n    // we create an overall container, then individual containers for the title and body\n\n    const adToken = this.createToken(\"admonition_open\", \"aside\", 1, {\n      map: data.map,\n      block: true\n    })\n    adToken.attrSet(\"class\", \"admonition\")\n    if (this.title) adToken.attrJoin(\"class\", this.title.toLowerCase())\n    if (data.options.class) {\n      adToken.attrJoin(\"class\", data.options.class.join(\" \"))\n    }\n    newTokens.push(adToken)\n\n    const adTokenTitle = this.createToken(\"admonition_title_open\", \"header\", 1)\n    adTokenTitle.attrSet(\"class\", \"admonition-title\")\n    newTokens.push(adTokenTitle)\n\n    // we want the title to be parsed as Markdown during the inline phase\n    const title = data.args[0] || this.title\n    newTokens.push(\n      this.createToken(\"inline\", \"\", 0, {\n        map: [data.map[0], data.map[0]],\n        content: title,\n        children: []\n      })\n    )\n\n    newTokens.push(\n      this.createToken(\"admonition_title_close\", \"header\", -1, { block: true })\n    )\n\n    // run a recursive parse on the content of the admonition upto this stage\n    const bodyTokens = this.nestedParse(data.body, data.bodyMap[0])\n    newTokens.push(...bodyTokens)\n\n    newTokens.push(this.createToken(\"admonition_close\", \"aside\", -1, { block: true }))\n\n    return newTokens\n  }\n}\n\nexport class Admonition extends BaseAdmonition {\n  public required_arguments = 1\n}\n\nexport class Attention extends BaseAdmonition {\n  public title = \"Attention\"\n}\n\nexport class Caution extends BaseAdmonition {\n  public title = \"Caution\"\n}\n\nexport class Danger extends BaseAdmonition {\n  public title = \"Danger\"\n}\n\nexport class Error extends BaseAdmonition {\n  public title = \"Error\"\n}\n\nexport class Important extends BaseAdmonition {\n  public title = \"Important\"\n}\n\nexport class Hint extends BaseAdmonition {\n  public title = \"Hint\"\n}\n\nexport class Note extends BaseAdmonition {\n  public title = \"Note\"\n}\n\nexport class SeeAlso extends BaseAdmonition {\n  public title = \"See Also\"\n}\n\nexport class Tip extends BaseAdmonition {\n  public title = \"Tip\"\n}\n\nexport class Warning extends BaseAdmonition {\n  public title = \"Warning\"\n}\n\nexport const admonitions = {\n  admonition: Admonition,\n  attention: Attention,\n  caution: Caution,\n  danger: Danger,\n  error: Error,\n  important: Important,\n  hint: Hint,\n  note: Note,\n  seealso: SeeAlso,\n  tip: Tip,\n  warning: Warning\n}\n","/** Admonitions to visualise programming codes */\nimport type Token from \"markdown-it/lib/token\"\nimport { Directive, IDirectiveData } from \"./main\"\nimport {\n  class_option,\n  flag,\n  int,\n  optional_int,\n  unchanged,\n  unchanged_required\n} from \"./options\"\n\n// TODO add Highlight directive\n\n/** Mark up content of a code block\n *\n * Adapted from sphinx/directives/patches.py\n */\nexport class Code extends Directive {\n  public required_arguments = 0\n  public optional_arguments = 1\n  public final_argument_whitespace = false\n  public has_content = true\n  public option_spec = {\n    /** Add line numbers, optionally starting from a particular number. */\n    \"number-lines\": optional_int,\n    /** Ignore minor errors on highlighting */\n    force: flag,\n    name: unchanged,\n    class: class_option\n  }\n  run(data: IDirectiveData<keyof Code[\"option_spec\"]>): Token[] {\n    // TODO handle options\n    this.assert_has_content(data)\n    const token = this.createToken(\"fence\", \"code\", 0, {\n      // TODO if not specified, the language should come from a central configuration \"highlight_language\"\n      info: data.args ? data.args[0] : \"\",\n      content: data.body,\n      map: data.bodyMap\n    })\n    return [token]\n  }\n}\n\n/** Mark up content of a code block, with more settings\n *\n * Adapted from sphinx/directives/code.py\n */\nexport class CodeBlock extends Directive {\n  public required_arguments = 0\n  public optional_arguments = 1\n  public final_argument_whitespace = false\n  public has_content = true\n  public option_spec = {\n    /** Add line numbers. */\n    linenos: flag,\n    /** Start line numbering from a particular value. */\n    \"lineno-start\": int,\n    /** Strip indentation characters from the code block.\n     * When number given, leading N characters are removed\n     */\n    dedent: optional_int,\n    /** Emphasize particular lines (comma-separated numbers) */\n    \"emphasize-lines\": unchanged_required,\n    caption: unchanged_required,\n    /** Ignore minor errors on highlighting */\n    force: flag,\n    name: unchanged,\n    class: class_option\n  }\n  run(data: IDirectiveData<keyof CodeBlock[\"option_spec\"]>): Token[] {\n    // TODO handle options\n    this.assert_has_content(data)\n    const token = this.createToken(\"fence\", \"code\", 0, {\n      // TODO if not specified, the language should come from a central configuration \"highlight_language\"\n      info: data.args ? data.args[0] : \"\",\n      content: data.body,\n      map: data.bodyMap\n    })\n    return [token]\n  }\n}\n\n/** A code cell is a special MyST based cell, signifying executable code. */\nexport class CodeCell extends Directive {\n  public required_arguments = 0\n  public optional_arguments = 1\n  public final_argument_whitespace = false\n  public has_content = true\n  public rawOptions = true\n\n  run(data: IDirectiveData<keyof CodeCell[\"option_spec\"]>): Token[] {\n    // TODO store options and the fact that this is a code cell rather than a fence?\n    const token = this.createToken(\"fence\", \"code\", 0, {\n      info: data.args ? data.args[0] : \"\",\n      content: data.body,\n      map: data.bodyMap\n    })\n    return [token]\n  }\n}\n\nexport const code = {\n  code: Code,\n  \"code-block\": CodeBlock,\n  \"code-cell\": CodeCell\n}\n","/** Directives for image visualisation */\nimport type Token from \"markdown-it/lib/token\"\nimport { Directive, IDirectiveData } from \"./main\"\nimport {\n  class_option,\n  create_choice,\n  length_or_percentage_or_unitless,\n  length_or_percentage_or_unitless_figure,\n  length_or_unitless,\n  percentage,\n  unchanged,\n  unchanged_required,\n  uri\n} from \"./options\"\n\nconst shared_option_spec = {\n  alt: unchanged,\n  height: length_or_unitless,\n  width: length_or_percentage_or_unitless,\n  // TODO handle scale option\n  scale: percentage,\n  // TODO handle target option\n  target: unchanged_required,\n  class: class_option,\n  // TODO handle name option (note: should be applied to figure for Figure)\n  name: unchanged\n}\n\n/** Directive for a single image.\n *\n * Adapted from: docutils/docutils/parsers/rst/directives/images.py\n */\nexport class Image extends Directive {\n  public required_arguments = 1\n  public optional_arguments = 0\n  public final_argument_whitespace = true\n  public option_spec = {\n    ...shared_option_spec,\n    align: create_choice([\"left\", \"center\", \"right\", \"top\", \"middle\", \"bottom\"])\n  }\n  create_image(data: IDirectiveData<keyof Image[\"option_spec\"]>): Token {\n    // get URI\n    const src = uri(data.args[0] || \"\")\n\n    const token = this.createToken(\"image\", \"img\", 0, { map: data.map })\n    token.attrSet(\"src\", src)\n    token.attrSet(\"alt\", data.options.alt || \"\")\n    // TODO markdown-it default renderer requires the alt as children tokens\n    const altTokens: Token[] = []\n    if (data.options.alt) {\n      this.state.md.inline.parse(\n        data.options.alt,\n        this.state.md,\n        this.state.env,\n        altTokens\n      )\n    }\n    token.children = altTokens\n    if (data.options.height) {\n      token.attrSet(\"height\", data.options.height)\n    }\n    if (data.options.width) {\n      token.attrSet(\"width\", data.options.width)\n    }\n    if (data.options.align) {\n      token.attrJoin(\"class\", `align-${data.options.align}`)\n    }\n    if (data.options.class) {\n      token.attrJoin(\"class\", data.options.class.join(\" \"))\n    }\n\n    return token\n  }\n  run(data: IDirectiveData): Token[] {\n    return [this.create_image(data)]\n  }\n}\n\n/** Directive for an image with caption.\n *\n * Adapted from: docutils/docutils/parsers/rst/directives/images.py,\n * and sphinx/directives/patches.py (patch to apply name to figure instead of image)\n */\nexport class Figure extends Image {\n  public option_spec = {\n    ...shared_option_spec,\n    align: create_choice([\"left\", \"center\", \"right\"]),\n    figwidth: length_or_percentage_or_unitless_figure,\n    figclass: class_option\n  }\n  public has_content = true\n  run(data: IDirectiveData<keyof Figure[\"option_spec\"]>): Token[] {\n    const openToken = this.createToken(\"figure_open\", \"figure\", 1, { map: data.map })\n    if (data.options.figclass) {\n      openToken.attrJoin(\"class\", data.options.figclass.join(\" \"))\n    }\n    if (data.options.align) {\n      openToken.attrJoin(\"class\", `align-${data.options.align}`)\n    }\n    if (data.options.figwidth && data.options.figwidth !== \"image\") {\n      // TODO handle figwidth == \"image\"?\n      openToken.attrSet(\"width\", data.options.figwidth)\n    }\n    const imageToken = this.create_image(data)\n    imageToken.map = [data.map[0], data.map[0]]\n    let captionTokens: Token[] = []\n    if (data.body) {\n      const openCaption = this.createToken(\"figure_caption_open\", \"figcaption\", 1)\n      // TODO in docutils caption can only be single paragraph (or ignored if comment)\n      // then additional content is figure legend\n      const captionBody = this.nestedParse(data.body, data.bodyMap[0])\n      const closeCaption = this.createToken(\"figure_caption_close\", \"figcaption\", -1)\n      captionTokens = [openCaption, ...captionBody, closeCaption]\n    }\n    const closeToken = this.createToken(\"figure_close\", \"figure\", -1)\n    return [openToken, imageToken, ...captionTokens, closeToken]\n  }\n}\n\nexport const images = {\n  image: Image,\n  figure: Figure\n}\n","/** A tree representation of a linear markdown-it token stream.\n *\n * Ported from: markdown-it-py/markdown_it/tree.py\n */\nimport Token from \"markdown-it/lib/token\"\n\ninterface NesterTokens {\n  opening: Token\n  closing: Token\n}\n\n/**A Markdown syntax tree node.\n\nA class that can be used to construct a tree representation of a linear\n`markdown-it` token stream.\n\nEach node in the tree represents either:\n    - root of the Markdown document\n    - a single unnested `Token`\n    - a `Token` \"_open\" and \"_close\" token pair, and the tokens nested in\n        between\n*/\nexport class SyntaxTreeNode {\n  private token?: Token\n  private nester_tokens?: NesterTokens\n  public parent?: SyntaxTreeNode\n  public children: SyntaxTreeNode[] = []\n  /** Initialize a `SyntaxTreeNode` from a token stream. */\n  constructor(tokens: Token[], create_root = true) {\n    this.children = []\n    if (create_root) {\n      this._set_children_from_tokens(tokens)\n      return\n    }\n    if (tokens.length === 0) {\n      throw new Error(\"Tree creation: Can only create root from empty token sequence.\")\n    }\n    if (tokens.length === 1) {\n      const inline_token = tokens[0]\n      if (inline_token.nesting) {\n        throw new Error(\"Unequal nesting level at the start and end of token stream.\")\n      }\n      this.token = inline_token\n      if (inline_token.children !== null && inline_token.children.length > 0) {\n        this._set_children_from_tokens(inline_token.children)\n      }\n    } else {\n      this.nester_tokens = { opening: tokens[0], closing: tokens[tokens.length - 1] }\n      this._set_children_from_tokens(tokens.slice(1, -1))\n    }\n  }\n  private _set_children_from_tokens(tokens: Token[]): void {\n    const revered_tokens = [...tokens].reverse()\n    let token: Token | undefined\n    while (revered_tokens.length > 0) {\n      token = revered_tokens.pop()\n      if (!token) {\n        break\n      }\n      if (!token.nesting) {\n        this._add_child([token])\n        continue\n      }\n      if (token.nesting !== 1) {\n        throw new Error(\"Invalid token nesting\")\n      }\n      const nested_tokens = [token]\n      let nesting = 1\n      while (revered_tokens.length > 0 && nesting !== 0) {\n        token = revered_tokens.pop()\n        if (token) {\n          nested_tokens.push(token)\n          nesting += token.nesting\n        }\n      }\n      if (nesting) {\n        throw new Error(`unclosed tokens starting: ${nested_tokens[0]}`)\n      }\n      this._add_child(nested_tokens)\n    }\n  }\n  private _add_child(tokens: Token[]): void {\n    const child = new SyntaxTreeNode(tokens, false)\n    child.parent = this\n    this.children.push(child)\n  }\n  /** Recover the linear token stream. */\n  to_tokens(): Token[] {\n    function recursive_collect_tokens(node: SyntaxTreeNode, token_list: Token[]): void {\n      if (node.type === \"root\") {\n        for (const child of node.children) {\n          recursive_collect_tokens(child, token_list)\n        }\n      } else if (node.token) {\n        token_list.push(node.token)\n      } else {\n        if (!node.nester_tokens) {\n          throw new Error(\"No nested token available\")\n        }\n        token_list.push(node.nester_tokens.opening)\n        for (const child of node.children) {\n          recursive_collect_tokens(child, token_list)\n        }\n        token_list.push(node.nester_tokens.closing)\n      }\n    }\n    const tokens: Token[] = []\n    recursive_collect_tokens(this, tokens)\n    return tokens\n  }\n  /** Is the node a special root node? */\n  get is_root(): boolean {\n    return !(this.token || this.nester_tokens)\n  }\n  /** Is this node nested? */\n  get is_nested(): boolean {\n    return !!this.nester_tokens\n  }\n  /** Get siblings of the node (including self). */\n  get siblings(): SyntaxTreeNode[] {\n    if (!this.parent) {\n      return [this]\n    }\n    return this.parent.children\n  }\n  /** Recursively yield all descendant nodes in the tree starting at self.\n   *\n   * The order mimics the order of the underlying linear token stream (i.e. depth first).\n   */\n  *walk(include_self = true): Generator<SyntaxTreeNode> {\n    if (include_self) {\n      yield this\n    }\n    for (const child of this.children) {\n      yield* child.walk(true)\n    }\n  }\n  /** Get a string type of the represented syntax.\n   * \n    - \"root\" for root nodes\n    - `Token.type` if the node represents an un-nested token\n    - `Token.type` of the opening token, with \"_open\" suffix stripped, if\n        the node represents a nester token pair\n  */\n  get type(): string {\n    if (this.is_root) {\n      return \"root\"\n    }\n    if (this.token) {\n      return this.token.type\n    }\n    if (this.nester_tokens?.opening.type.endsWith(\"_open\")) {\n      return this.nester_tokens?.opening.type.slice(0, -5)\n    }\n    if (this.nester_tokens) {\n      return this.nester_tokens?.opening.type\n    }\n    throw new Error(\"no internal token\")\n  }\n  private attribute_token(): Token {\n    if (this.token) {\n      return this.token\n    }\n    if (this.nester_tokens) {\n      return this.nester_tokens.opening\n    }\n    throw new Error(\"Tree node does not have the accessed attribute\")\n  }\n  get tag(): string {\n    return this.attribute_token().tag\n  }\n  get level(): number {\n    return this.attribute_token().level\n  }\n  get content(): string {\n    return this.attribute_token().content\n  }\n  get markup(): string {\n    return this.attribute_token().markup\n  }\n  get info(): string {\n    return this.attribute_token().info\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  get meta(): any {\n    return this.attribute_token().meta\n  }\n  get block(): boolean {\n    return this.attribute_token().block\n  }\n  get hidden(): boolean {\n    return this.attribute_token().hidden\n  }\n  get map(): [number, number] | null {\n    return this.attribute_token().map\n  }\n  get attrs(): [string, string][] | null {\n    return this.attribute_token().attrs\n  }\n}\n","/** Directives for creating tables */\nimport type Token from \"markdown-it/lib/token\"\nimport { SyntaxTreeNode } from \"../syntaxTree\"\nimport { Directive, DirectiveParsingError, IDirectiveData } from \"./main\"\nimport {\n  class_option,\n  create_choice,\n  length_or_percentage_or_unitless,\n  nonnegative_int,\n  unchanged\n} from \"./options\"\n\nexport class ListTable extends Directive {\n  public required_arguments = 0\n  public optional_arguments = 1\n  public final_argument_whitespace = true\n  public has_content = true\n  public option_spec = {\n    \"header-rows\": nonnegative_int,\n    \"stub-columns\": nonnegative_int,\n    width: length_or_percentage_or_unitless,\n    widths: unchanged, // TODO use correct widths option validator\n    class: class_option,\n    name: unchanged,\n    align: create_choice([\"left\", \"center\", \"right\"])\n  }\n  run(data: IDirectiveData): Token[] {\n    // TODO support all options (add colgroup for widths)\n    // Parse content\n    this.assert_has_content(data)\n    const headerRows = (data.options[\"header-rows\"] || 0) as number\n    const listTokens = this.nestedParse(data.body, data.bodyMap[0])\n    // Check content is a list\n    if (\n      listTokens.length < 2 ||\n      listTokens[0].type !== \"bullet_list_open\" ||\n      listTokens[listTokens.length - 1].type !== \"bullet_list_close\"\n    ) {\n      throw new DirectiveParsingError(\"Content is not a single bullet list\")\n    }\n\n    // generate tokens\n    const tokens: Token[] = []\n\n    // table opening\n    const tableOpen = this.createToken(\"table_open\", \"table\", 1, { map: data.bodyMap })\n    if (data.options.align) {\n      tableOpen.attrJoin(\"class\", `align-${data.options.align}`)\n    }\n    if (data.options.class) {\n      tableOpen.attrJoin(\"class\", data.options.class.join(\" \"))\n    }\n    tokens.push(tableOpen)\n\n    // add caption\n    if (data.args.length && data.args[0]) {\n      tokens.push(this.createToken(\"table_caption_open\", \"caption\", 1))\n      tokens.push(\n        this.createToken(\"inline\", \"\", 0, {\n          map: [data.map[0], data.map[0]],\n          content: data.args[0],\n          children: []\n        })\n      )\n      tokens.push(this.createToken(\"table_caption_close\", \"caption\", -1))\n    }\n\n    let colType: \"th\" | \"td\" = \"th\"\n    if (headerRows) {\n      tokens.push(this.createToken(\"thead_open\", \"thead\", 1, { level: 1 }))\n      colType = \"th\"\n    } else {\n      tokens.push(this.createToken(\"tbody_open\", \"tbody\", 1, { level: 1 }))\n      colType = \"td\"\n    }\n\n    let rowLength: number | undefined = undefined\n    let rowNumber = 0\n    for (const child of new SyntaxTreeNode(listTokens.slice(1, -1)).children) {\n      rowNumber += 1\n      this.assert(\n        child.type === \"list_item\",\n        `list item ${rowNumber} not of type 'list_item': ${child.type}`\n      )\n      this.assert(\n        child.children.length === 1 && child.children[0].type === \"bullet_list\",\n        `list item ${rowNumber} content not a nested bullet list`\n      )\n      const row = child.children[0].children\n      if (rowLength === undefined) {\n        rowLength = row.length\n      } else {\n        this.assert(\n          row.length === rowLength,\n          `list item ${rowNumber} does not contain the same number of columns as previous items`\n        )\n      }\n      if (headerRows && rowNumber === headerRows + 1) {\n        tokens.push(this.createToken(\"thead_close\", \"thead\", -1, { level: 1 }))\n        tokens.push(this.createToken(\"tbody_open\", \"tbody\", 1, { level: 1 }))\n        colType = \"td\"\n      }\n      tokens.push(this.createToken(\"tr_open\", \"tr\", 1, { map: child.map, level: 2 }))\n      for (const column of row) {\n        tokens.push(\n          this.createToken(`${colType}_open`, colType, 1, { map: column.map, level: 3 })\n        )\n        // TODO if the list is not tight then all paragraphs will be un-hidden maybe we don't want this?\n        tokens.push(...column.to_tokens().slice(1, -1))\n        tokens.push(this.createToken(`${colType}_close`, colType, -1, { level: 3 }))\n      }\n      tokens.push(this.createToken(\"tr_close\", \"tr\", -1, { level: 2 }))\n    }\n\n    if (headerRows && rowNumber < headerRows) {\n      throw new Error(\n        `Insufficient rows (${rowNumber}) for required header rows (${headerRows})`\n      )\n    }\n\n    // closing tokens\n    if (colType === \"td\") {\n      tokens.push(this.createToken(\"tbody_close\", \"tbody\", -1, { level: 1 }))\n    } else {\n      tokens.push(this.createToken(\"thead_close\", \"thead\", -1, { level: 1 }))\n    }\n    tokens.push(this.createToken(\"table_close\", \"table\", -1))\n\n    return tokens\n  }\n}\n\nexport const tables = {\n  \"list-table\": ListTable\n}\n","/** Admonitions to visualise programming codes */\nimport type Token from \"markdown-it/lib/token\"\nimport { Directive, IDirectiveData } from \"./main\"\nimport { unchanged } from \"./options\"\n\n/** Math directive with a label\n */\nexport class Math extends Directive {\n  public required_arguments = 0\n  public optional_arguments = 0\n  public final_argument_whitespace = false\n  public has_content = true\n  public option_spec = {\n    label: unchanged\n  }\n  run(data: IDirectiveData<keyof Math[\"option_spec\"]>): Token[] {\n    // TODO handle options\n    this.assert_has_content(data)\n    const token = this.createToken(\"math_block\", \"div\", 0, {\n      content: data.body,\n      map: data.bodyMap,\n      block: true\n    })\n    token.attrSet(\"class\", \"math block\")\n    if (data.options.label) {\n      token.info = data.options.label\n      token.meta = { label: data.options.label, numbered: true }\n    }\n    return [token]\n  }\n}\n\nexport const math = {\n  math: Math\n}\n","export { Directive } from \"./main\"\nexport { default as directivePlugin } from \"./plugin\"\nexport type { IOptions as IDirectiveOptions } from \"./types\"\n\nexport { admonitions } from \"./admonitions\"\nexport { code } from \"./code\"\nexport { images } from \"./images\"\nexport { tables } from \"./tables\"\nexport { math } from \"./math\"\n\nimport { admonitions } from \"./admonitions\"\nimport { code } from \"./code\"\nimport { images } from \"./images\"\nimport { tables } from \"./tables\"\nimport { math } from \"./math\"\n\nexport const directivesDefault = {\n  ...admonitions,\n  ...images,\n  ...code,\n  ...tables,\n  ...math\n}\n","import type MarkdownIt from \"markdown-it/lib\"\nimport { rolesDefault, Role, rolePlugin, IRoleOptions } from \"./roles\"\nimport {\n  directivesDefault,\n  Directive,\n  directivePlugin,\n  IDirectiveOptions\n} from \"./directives\"\n\nexport { rolesDefault, rolePlugin, Role }\nexport { directivesDefault, directivePlugin, Directive }\n\n/** Allowed options for docutils plugin */\nexport interface IOptions extends IDirectiveOptions, IRoleOptions {\n  // TODO new token render rules\n}\n\n/** Default options for docutils plugin */\nconst OptionDefaults: IOptions = {\n  parseRoles: true,\n  replaceFences: true,\n  rolesAfter: \"inline\",\n  directivesAfter: \"block\",\n  directives: directivesDefault,\n  roles: rolesDefault\n}\n\n/**\n * A markdown-it plugin for implementing docutils style roles and directives.\n */\nexport default function docutilsPlugin(md: MarkdownIt, options?: IOptions): void {\n  const fullOptions = { ...OptionDefaults, ...options }\n\n  rolePlugin(md, fullOptions)\n  directivePlugin(md, fullOptions)\n}\n"],"names":["Role","[object Object]","state","this","data","main","raw","token","Token","content","INLINE_MATH_RULE","math","inline","attrSet","markup","rolePlugin","md","options","parseRoles","ruler","before","roleRule","core","after","rolesAfter","roles","func","tokens","type","children","childTokens","child","meta","name","newTokens","run","parentMap","map","push","err","errorToken","info","error_message","message","error_name","runRoles","renderer","rules","idx","opts","c","utils","escapeHtml","trim","displayMode","attrGet","inlineMathRenderer","silent","src","charCodeAt","pos","match","ROLE_PATTERN","exec","slice","str","length","_x","RegExp","error","Subscript","open","text","close","ABBR_PATTERN","Abbreviation","title","html","subscript","sub","superscript","sup","abbreviation","abbr","rolesDefault","isNothing","subject","YAMLException","reason","mark","Error","call","toString","captureStackTrace","constructor","stack","sequence","Array","isArray","string","count","cycle","result","number","Number","NEGATIVE_INFINITY","target","source","index","key","sourceKeys","Object","keys","prototype","create","compact","exception","common","require$$0","Mark","buffer","position","line","column","getSnippet","indent","maxLength","head","start","tail","end","snippet","indexOf","charAt","repeat","where","TYPE_CONSTRUCTOR_OPTIONS","YAML_NODE_KINDS","tag","forEach","kind","resolve","construct","instanceOf","predicate","represent","defaultStyle","styleAliases","style","alias","String","compileStyleAliases","require$$1","Type","require$$2","compileList","schema","exclude","include","includedSchema","currentType","previousType","previousIndex","filter","Schema","definition","implicit","explicit","loadKind","compiledImplicit","compiledExplicit","compiledTypeMap","scalar","mapping","fallback","collectType","arguments","compileMap","DEFAULT","schemas","types","toArray","every","failsafe","_null","max","object","canonical","lowercase","uppercase","camelcase","bool","isOctCode","isDecCode","int","ch","hasDigits","test","base","value","sign","digits","replace","parseInt","split","v","unshift","d","isNegativeZero","binary","obj","octal","decimal","hexadecimal","toUpperCase","YAML_FLOAT_PATTERN","SCIENTIFIC_WITHOUT_DOT","json","require$$3","require$$4","toLowerCase","POSITIVE_INFINITY","NaN","parseFloat","res","isNaN","YAML_DATE_REGEXP","YAML_TIMESTAMP_REGEXP","timestamp","year","month","day","hour","minute","second","date","fraction","delta","Date","UTC","setTime","getTime","toISOString","NodeBuffer","merge","require","Buffer","__","BASE64_MAP","code","bitlen","tailbits","input","bits","from","isBuffer","_hasOwnProperty","hasOwnProperty","_toString","omap","pair","pairKey","pairHasKey","objectKeys","pairs","default_safe","require$$5","require$$6","_undefined","esprima","regexp","modifiers","global","multiline","ignoreCase","_","window","_function","ast","parse","range","body","expression","params","param","Function","default_full","DEFAULT_SAFE_SCHEMA","DEFAULT_FULL_SCHEMA","PATTERN_NON_PRINTABLE","PATTERN_NON_ASCII_LINE_BREAKS","PATTERN_FLOW_INDICATORS","PATTERN_TAG_HANDLE","PATTERN_TAG_URI","_class","is_EOL","is_WHITE_SPACE","is_WS_OR_EOL","is_FLOW_INDICATOR","fromHexCode","lc","simpleEscapeSequence","charFromCodepoint","fromCharCode","simpleEscapeCheck","simpleEscapeMap","i","State","filename","onWarning","legacy","listener","implicitTypes","typeMap","lineStart","lineIndent","documents","generateError","throwError","throwWarning","directiveHandlers","YAML","args","major","minor","version","checkLineBreaks","TAG","handle","prefix","tagMap","captureSegment","checkJson","_position","_length","_character","_result","mergeMappings","destination","overridableKeys","quantity","isObject","storeMappingPair","keyTag","keyNode","valueNode","startLine","startPos","readLineBreak","skipSeparationSpace","allowComments","checkIndent","lineBreaks","testDocumentSeparator","writeFoldedLines","readBlockSequence","nodeIndent","_line","_tag","_anchor","anchor","detected","anchorMap","composeNode","readTagProperty","tagHandle","tagName","isVerbatim","isNamed","readAnchorProperty","parentIndent","nodeContext","allowToSeek","allowCompact","allowBlockStyles","allowBlockScalars","allowBlockCollections","typeIndex","typeQuantity","flowIndent","blockIndent","indentStatus","atNewLine","hasContent","following","_pos","atExplicitKey","readBlockMapping","terminator","isPair","isExplicitPair","isMapping","readNext","readFlowCollection","captureStart","folding","tmp","chomping","didReadContent","detectedIndent","textIndent","emptyLines","atMoreIndented","readBlockScalar","captureEnd","readSingleQuotedScalar","hexLength","hexResult","readDoubleQuotedScalar","readAlias","withinFlowCollection","hasPendingContent","_lineStart","_lineIndent","_kind","readPlainScalar","readDocument","directiveName","directiveArgs","documentStart","hasDirectives","loadDocuments","nullpos","loadAll","iterator","load","extend","ESCAPE_SEQUENCES","DEPRECATED_BOOLEANS_SYNTAX","encodeHex","character","Math","noArrayIndent","skipInvalid","flowLevel","styleMap","compileStyleMap","sortKeys","lineWidth","noRefs","noCompatMode","condenseFlow","explicitTypes","duplicates","usedDuplicates","indentString","spaces","ind","next","generateNextLine","level","isWhitespace","isPrintable","isPlainSafe","prev","isNsChar","needIndentIndicator","chooseScalarStyle","singleLineOnly","indentPerLevel","testAmbiguousType","char","prev_char","hasLineBreak","hasFoldableLine","shouldTrackWidth","previousLineBreak","plain","writeScalar","iskey","dump","min","testImplicitResolving","blockHeader","dropEndingNewline","width","moreIndented","lineRe","nextLF","lastIndex","foldLine","prevMoreIndented","foldString","nextChar","escapeSeq","escapeString","indentIndicator","clip","breakRe","curr","detectType","typeList","writeNode","block","duplicateIndex","duplicate","objectOrArray","objectKey","objectValue","explicitPair","pairBuffer","objectKeyList","sort","writeBlockMapping","writeFlowMapping","arrayLevel","writeBlockSequence","writeFlowSequence","getDuplicateReferences","objects","duplicatesIndexes","inspectNode","loader","dumper","deprecated","require$$7","require$$8","safeLoad","safeLoadAll","safeDump","require$$9","jsYaml","Directive","msg","nesting","optional","undefined","initLine","pluginRuleName","env","includeRule","tempDisabledCore","rule","__rules__","reverse","disable","enable","nestedCoreParse","DirectiveParsingError","directiveToData","directive","firstLine","arg","bodyOffset","option_spec","rawOptions","fullSpec","yamlBlock","startsWith","newContent","foundDivider","output","yaml","join","entries","convertor","converted_value","parseDirectiveOptions","required_arguments","optional_arguments","totalArgs","final_argument_whitespace","arr","splice","parseDirectiveArguments","concat","shift","has_content","bodyMap","directivePlugin","directivesAfter","replaceFences","directives","finalTokens","runDirectives","OptionSpecError","unchanged","unchanged_required","flag","class_option","make_id","argument","isInteger","nonnegative_int","optional_int","get_measure","units","groups","length_units","length_or_unitless","length_or_percentage_or_unitless","defaultUnit","length_or_percentage_or_unitless_figure","create_choice","choices","includes","BaseAdmonition","class","adToken","createToken","attrJoin","adTokenTitle","bodyTokens","nestedParse","admonitions","admonition","attention","caution","danger","important","hint","note","seealso","tip","warning","number-lines","force","assert_has_content","code-block","linenos","lineno-start","dedent","emphasize-lines","caption","code-cell","shared_option_spec","alt","height","scale","Image","align","altTokens","create_image","images","image","figure","figwidth","figclass","openToken","imageToken","captionTokens","closeToken","SyntaxTreeNode","create_root","_set_children_from_tokens","inline_token","nester_tokens","opening","closing","revered_tokens","pop","_add_child","nested_tokens","parent","recursive_collect_tokens","node","token_list","is_root","is_nested","siblings","include_self","walk","endsWith","attribute_token","hidden","attrs","tables","list-table","header-rows","stub-columns","widths","headerRows","listTokens","tableOpen","rowLength","colType","rowNumber","assert","row","to_tokens","label","numbered","directivesDefault","OptionDefaults","fullOptions"],"mappings":"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"}