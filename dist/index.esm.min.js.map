{"version":3,"file":"index.esm.min.js","sources":["../src/roles/main.ts","../src/roles/math.ts","../src/roles/plugin.ts","../src/roles/html.ts","../src/state/utils.ts","../src/roles/references.ts","../src/roles/index.ts","../node_modules/js-yaml/dist/js-yaml.mjs","../src/directives/main.ts","../src/nestedCoreParse.ts","../src/directives/plugin.ts","../src/directives/options.ts","../src/directives/admonitions.ts","../src/directives/code.ts","../src/directives/images.ts","../src/syntaxTree.ts","../src/directives/tables.ts","../src/directives/math.ts","../src/directives/index.ts","../src/state/plugin.ts","../src/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport type StateCore from \"markdown-it/lib/rules_core/state_core\"\nimport type Token from \"markdown-it/lib/token\"\n\n/** Data structure of a role */\nexport interface IRoleData {\n  /** The map of the containing inline token */\n  parentMap: [number, number] | null\n  // TODO how to get line and position in line?\n  content: string\n  // TODO validate/convert\n  options?: { [key: string]: any }\n}\n\n/** A class to define a single role */\nexport class Role {\n  public state: StateCore\n  constructor(state: StateCore) {\n    this.state = state\n  }\n  /** Convert the role to tokens */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  run(data: IRoleData): Token[] {\n    return []\n  }\n}\n\nexport class RawRole extends Role {\n  run(data: IRoleData): Token[] {\n    // TODO options\n    const token = new this.state.Token(\"code_inline\", \"code\", 0)\n    token.content = data.content\n    return [token]\n  }\n}\n\nexport const main = {\n  raw: RawRole\n}\n","/**\n * This module contains roles that relate to mathematics\n */\nimport type MarkdownIt from \"markdown-it/lib\"\nimport type Token from \"markdown-it/lib/token\"\nimport { IRoleData, Role } from \"./main\"\nimport { IOptions } from \"./types\"\n\nconst INLINE_MATH_RULE = \"math_inline\"\n\nexport class Math extends Role {\n  run(data: IRoleData): Token[] {\n    const inline = new this.state.Token(INLINE_MATH_RULE, \"span\", 0)\n    inline.attrSet(\"class\", \"math inline\")\n    inline.markup = \"$\"\n    inline.content = data.content\n    return [inline]\n  }\n}\n\nexport function inlineMathRenderer(md: MarkdownIt, options?: IOptions): void {\n  // Only create the renderer if it does not exist\n  // For example, this may be defined in markdown-it-dollarmath\n  if (!options?.roles?.math || md.renderer.rules[INLINE_MATH_RULE]) return\n\n  md.renderer.rules[INLINE_MATH_RULE] = (tokens, idx) => {\n    const renderer = options?.opts?.math?.renderer ?? (c => md.utils.escapeHtml(c))\n    const token = tokens[idx]\n    const content = token.content.trim()\n    const math = renderer(content, { displayMode: false })\n    return `<span class=\"${token.attrGet(\"class\")}\">${math}</span>`\n  }\n}\n\nexport const math = {\n  math: Math\n}\n","/** Parse a role, in MyST format */\n// Ported from https://github.com/executablebooks/markdown-it-py/blob/master/markdown_it/extensions/myst_role/index.py\n// MIT License: https://github.com/executablebooks/markdown-it-py/blob/master/LICENSE\n\nimport type MarkdownIt from \"markdown-it/lib\"\nimport type StateCore from \"markdown-it/lib/rules_core/state_core\"\nimport type StateInline from \"markdown-it/lib/rules_inline/state_inline\"\nimport { Role } from \"./main\"\nimport { IOptions } from \"./types\"\nimport { inlineMathRenderer } from \"./math\"\n\nexport default function rolePlugin(md: MarkdownIt, options: IOptions): void {\n  if (options.parseRoles) {\n    md.inline.ruler.before(\"backticks\", \"parse_roles\", roleRule)\n  }\n  md.core.ruler.after(\n    options.rolesAfter || \"inline\",\n    \"run_roles\",\n    runRoles(options.roles || {})\n  )\n  // fallback renderer for unhandled roles\n  md.renderer.rules[\"role\"] = (tokens, idx) => {\n    const token = tokens[idx]\n    return `<span class=\"role-unhandled\"><mark>${token.meta.name}</mark><code>${token.content}</code></span>`\n  }\n\n  // TODO: when another renderer comes up, refactor into something a bit more scalable\n  inlineMathRenderer(md, options)\n\n  // TODO role_error renderer\n}\n\nfunction roleRule(state: StateInline, silent: boolean): boolean {\n  // Check if the role is escaped\n  if (state.src.charCodeAt(state.pos - 1) === 0x5c) {\n    /* \\ */\n    // TODO: this could be improved in the case of edge case '\\\\{', also multi-line\n    return false\n  }\n  const match = ROLE_PATTERN.exec(state.src.slice(state.pos))\n  if (match == null) return false\n  const [str, name, , content] = match\n  // eslint-disable-next-line no-param-reassign\n  state.pos += str.length\n\n  if (!silent) {\n    const token = state.push(\"role\", \"\", 0)\n    token.meta = { name }\n    token.content = content\n  }\n  return true\n}\n\n// MyST role syntax format e.g. {role}`text`\n// TODO: support role with no value e.g. {role}``\nlet _x: RegExp\ntry {\n  _x = new RegExp(\"^\\\\{([a-zA-Z_\\\\-+:]{1,36})\\\\}(`+)(?!`)(.+?)(?<!`)\\\\2(?!`)\")\n} catch (error) {\n  // Safari does not support negative look-behinds\n  // This is a slightly down-graded variant, as it does not require a space.\n  _x = /^\\{([a-zA-Z_\\-+:]{1,36})\\}(`+)(?!`)(.+?)\\2(?!`)/\n}\nconst ROLE_PATTERN = _x\n\n/** Run all roles, replacing the original token */\nfunction runRoles(roles: {\n  [key: string]: typeof Role\n}): (state: StateCore) => boolean {\n  function func(state: StateCore): boolean {\n    for (const token of state.tokens) {\n      if (token.type === \"inline\" && token.children) {\n        const childTokens = []\n        for (const child of token.children) {\n          // TODO role name translations\n          if (child.type === \"role\" && child.meta?.name in roles) {\n            try {\n              const role = new roles[child.meta.name](state)\n              const roleOpen = new state.Token(\"parsed_role_open\", \"\", 1)\n              roleOpen.content = child.content\n              roleOpen.hidden = true\n              roleOpen.meta = { name: child.meta.name }\n              roleOpen.block = false\n              const newTokens = [roleOpen]\n              newTokens.push(\n                ...role.run({\n                  parentMap: token.map,\n                  content: child.content\n                })\n              )\n              const roleClose = new state.Token(\"parsed_role_close\", \"\", -1)\n              roleClose.block = false\n              roleClose.hidden = true\n              newTokens.push(roleClose)\n              childTokens.push(...newTokens)\n            } catch (err) {\n              const errorToken = new state.Token(\"role_error\", \"\", 0)\n              errorToken.content = child.content\n              errorToken.info = child.info\n              errorToken.meta = child.meta\n              errorToken.map = child.map\n              errorToken.meta.error_message = (err as Error).message\n              errorToken.meta.error_name = (err as Error).name\n              childTokens.push(errorToken)\n            }\n          } else {\n            childTokens.push(child)\n          }\n        }\n        token.children = childTokens\n      }\n    }\n    return true\n  }\n  return func\n}\n","/**\n * This module contains roles that directly map to HTML semantic tags\n */\nimport type Token from \"markdown-it/lib/token\"\nimport { IRoleData, Role } from \"./main\"\n\nexport class Subscript extends Role {\n  run(data: IRoleData): Token[] {\n    const open = new this.state.Token(\"sub_open\", \"sub\", 1)\n    open.markup = \"~\"\n    const text = new this.state.Token(\"text\", \"\", 0)\n    text.content = data.content\n    const close = new this.state.Token(\"sub_close\", \"sub\", -1)\n    close.markup = \"~\"\n    return [open, text, close]\n  }\n}\n\nexport class Superscript extends Role {\n  run(data: IRoleData): Token[] {\n    const open = new this.state.Token(\"sup_open\", \"sup\", 1)\n    open.markup = \"~\"\n    const text = new this.state.Token(\"text\", \"\", 0)\n    text.content = data.content\n    const close = new this.state.Token(\"sup_close\", \"sup\", -1)\n    close.markup = \"~\"\n    return [open, text, close]\n  }\n}\n\nconst ABBR_PATTERN = /^(.+?)\\(([^()]+)\\)$/ // e.g. 'CSS (Cascading Style Sheets)'\n\nexport class Abbreviation extends Role {\n  run(data: IRoleData): Token[] {\n    const match = ABBR_PATTERN.exec(data.content)\n    const content = match?.[1]?.trim() ?? data.content.trim()\n    const title = match?.[2]?.trim() ?? null\n    const open = new this.state.Token(\"abbr_open\", \"abbr\", 1)\n    if (title) open.attrSet(\"title\", title)\n    const text = new this.state.Token(\"text\", \"\", 0)\n    text.content = content\n    const close = new this.state.Token(\"abbr_close\", \"abbr\", -1)\n    return [open, text, close]\n  }\n}\n\nexport const html = {\n  // Subscript\n  subscript: Subscript,\n  sub: Subscript,\n  // Superscript\n  superscript: Superscript,\n  sup: Superscript,\n  // Abbreviation\n  abbreviation: Abbreviation,\n  abbr: Abbreviation\n}\n","import StateCore from \"markdown-it/lib/rules_core/state_core\"\nimport Token from \"markdown-it/lib/token\"\n\n/** The kind of the target as a TargetKind enum ('fig', 'eq', etc.) */\nexport enum TargetKind {\n  equation = \"eq\",\n  figure = \"fig\",\n  table = \"table\",\n  code = \"code\",\n  section = \"sec\"\n}\n\n/**\n * Targets are created by figures or equations.\n * They are \"things\" that you can reference in documentation, e.g. Figure 1.\n */\nexport type Target = {\n  /** The identifier or label of the target. */\n  label: string\n  /** TargetKind enum ('fig', 'eq', etc.) or a custom string */\n  kind: TargetKind | string\n  /** The default title that may be resolved in other places in a document. */\n  title: string // TODO: This should support markdown.\n  /** This is the number that will be given to this target.\n   * Note that it may be a `Number` or a `String` depending on\n   * if there is Section numbering in place (e.g. `Figure 1.2`)\n   */\n  number: number | string\n}\n\nexport type Reference = {\n  /** The identifier or label of the target. */\n  label: string\n  tokens: { open: Token; content: Token; close: Token }\n  /** TargetKind enum ('fig', 'eq', etc.) or a custom string */\n  kind?: TargetKind | string\n  /** Return the content that should be shown in a reference given a target.\n   *\n   * For example, in a `numref`, you will replace `%s` with the `target.number`.\n   */\n  contentFromTarget?: (target: Target) => string\n}\n\n/**\n * The `DocState` keeps track of targets, references and numbering.\n *\n * This is on the the state.env (see `getDocState`), and there\n * should only be one per markdown-it instance.\n */\nexport type DocState = {\n  // Targets are something to link to, they are aranged by `name`, use `newTarget`\n  targets: Record<string, Target>\n  // Use `resolveRefLater` function to provide a reference that will resolve\n  references: Reference[]\n  // Keep track of numbering totals for any known, or arbitrary targets\n  numbering: Record<TargetKind | string, number> // TODO: this can also be a string\n}\n\n/** Safely create the document state for docutils */\nexport function getDocState(state: StateCore): DocState {\n  const env = (state.env?.docutils as DocState) ?? {}\n  if (!env.targets) env.targets = {}\n  if (!env.references) env.references = []\n  if (!env.numbering) env.numbering = {}\n  if (!state.env.docutils) state.env.docutils = env\n  return env\n}\n\n/**\n * This is the information on `token.meta.docutils`\n */\nexport type MetaState = {\n  /** Target included in the `token.meta.docutils` state. */\n  target: Target\n}\n\n/**\n * Safely create a namespaced meta information on a token\n * @param token A markdown-it token that will contain the target\n * @returns An object containing a `Target`\n */\nexport function getNamespacedMeta(token: Token): MetaState {\n  const meta = token.meta?.docutils ?? {}\n  if (!token.meta) token.meta = {}\n  if (!token.meta.docutils) token.meta.docutils = meta\n  return meta\n}\n\n/** Get the next number for an equation, figure, code or table\n *\n * Can input `{ docutils: { numbering: { eq: 100 } } }` to start counting at a different number.\n *\n * @param state MarkdownIt state that will be modified\n */\nfunction nextNumber(state: StateCore, kind: TargetKind | string) {\n  const env = getDocState(state)\n  if (env.numbering[kind] == null) {\n    env.numbering[kind] = 1\n  } else {\n    env.numbering[kind] += 1\n  }\n  return env.numbering[kind]\n}\n\n/** Create a new internal target.\n *\n * @param state MarkdownIt state that will be modified\n * @param label The reference label that will be normalized and used to associate the target. Note some directives use \"name\".\n * @param kind The target kind: \"eq\", \"code\", \"table\" or \"fig\"\n */\nexport function newTarget(\n  state: StateCore,\n  token: Token,\n  kind: TargetKind,\n  label: string,\n  title: string,\n  silent = false\n): Target {\n  const env = getDocState(state)\n  const number = nextNumber(state, kind)\n  const target: Target = {\n    label,\n    kind,\n    number,\n    title\n  }\n  if (!silent) {\n    // Put the token in both the token.meta and the central environment\n    const meta = getNamespacedMeta(token)\n    meta.target = target\n    token.attrSet(\"id\", label)\n    // TODO: raise error on duplicates\n    env.targets[label] = target\n  }\n  return target\n}\n\n/**\n * Resolve a reference **in-place** in a following numbering pass.\n *\n * @param state Reference to the state object\n * @param tokens The open/content/close tokens of the reference\n * @param name Name/label/identifier of the target\n * @param opts Includes the reference `kind` and an optional way to create the reference content\n */\nexport function resolveRefLater(\n  state: StateCore,\n  tokens: Reference[\"tokens\"],\n  data: { label: string; kind: string; value?: string },\n  opts?: {\n    kind?: TargetKind\n    contentFromTarget?: Reference[\"contentFromTarget\"]\n  }\n): void {\n  tokens.open.meta = tokens.open.meta ?? {}\n  tokens.open.meta.kind = data.kind\n  tokens.open.meta.label = data.label\n  tokens.open.meta.value = data.value\n  const env = getDocState(state)\n  env.references.push({\n    label: data.label,\n    tokens,\n    ...opts\n  })\n}\n","import type Token from \"markdown-it/lib/token\"\nimport { resolveRefLater, TargetKind } from \"../state/utils\"\nimport { IRoleData, Role } from \"./main\"\n\nconst REF_PATTERN = /^(.+?)<([^<>]+)>$/ // e.g. 'Labeled Reference <ref>'\n\nexport class Eq extends Role {\n  run(data: IRoleData): Token[] {\n    const open = new this.state.Token(\"ref_open\", \"a\", 1)\n    const content = new this.state.Token(\"text\", \"\", 0)\n    const close = new this.state.Token(\"ref_close\", \"a\", -1)\n    resolveRefLater(\n      this.state,\n      { open, content, close },\n      { kind: \"eq\", label: data.content },\n      {\n        kind: TargetKind.equation,\n        contentFromTarget: target => {\n          return `(${target.number})`\n        }\n      }\n    )\n    return [open, content, close]\n  }\n}\n\nexport class NumRef extends Role {\n  run(data: IRoleData): Token[] {\n    const match = REF_PATTERN.exec(data.content)\n    const [, modified, ref] = match ?? []\n    const withoutLabel = modified?.trim()\n    const open = new this.state.Token(\"ref_open\", \"a\", 1)\n    const content = new this.state.Token(\"text\", \"\", 0)\n    const close = new this.state.Token(\"ref_close\", \"a\", -1)\n    resolveRefLater(\n      this.state,\n      { open, content, close },\n      { kind: \"numref\", label: ref || data.content, value: withoutLabel },\n      {\n        contentFromTarget: target => {\n          if (!match) return target.title.trim()\n          return withoutLabel\n            .replace(/%s/g, String(target.number))\n            .replace(/\\{number\\}/g, String(target.number))\n        }\n      }\n    )\n    return [open, content, close]\n  }\n}\n\nexport class Ref extends Role {\n  run(data: IRoleData): Token[] {\n    const match = REF_PATTERN.exec(data.content)\n    const [, modified, ref] = match ?? []\n    const withoutLabel = modified?.trim()\n    const open = new this.state.Token(\"ref_open\", \"a\", 1)\n    const content = new this.state.Token(\"text\", \"\", 0)\n    const close = new this.state.Token(\"ref_close\", \"a\", -1)\n    resolveRefLater(\n      this.state,\n      { open, content, close },\n      { kind: \"ref\", label: ref || data.content, value: withoutLabel },\n      {\n        contentFromTarget: target => {\n          return withoutLabel || target.title\n        }\n      }\n    )\n    return [open, content, close]\n  }\n}\n\nexport const references = {\n  eq: Eq,\n  ref: Ref,\n  numref: NumRef\n}\n","export { Role, main, IRoleData } from \"./main\"\nexport { default as rolePlugin } from \"./plugin\"\nexport type { IOptions as IRoleOptions } from \"./types\"\nexport { math } from \"./math\"\nexport { html } from \"./html\"\nexport { references } from \"./references\"\n\nimport { main } from \"./main\"\nimport { math } from \"./math\"\nimport { html } from \"./html\"\nimport { references } from \"./references\"\n\nexport const rolesDefault = { ...main, ...html, ...math, ...references }\n","\n/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */\nfunction isNothing(subject) {\n  return (typeof subject === 'undefined') || (subject === null);\n}\n\n\nfunction isObject(subject) {\n  return (typeof subject === 'object') && (subject !== null);\n}\n\n\nfunction toArray(sequence) {\n  if (Array.isArray(sequence)) return sequence;\n  else if (isNothing(sequence)) return [];\n\n  return [ sequence ];\n}\n\n\nfunction extend(target, source) {\n  var index, length, key, sourceKeys;\n\n  if (source) {\n    sourceKeys = Object.keys(source);\n\n    for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n      key = sourceKeys[index];\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n\nfunction repeat(string, count) {\n  var result = '', cycle;\n\n  for (cycle = 0; cycle < count; cycle += 1) {\n    result += string;\n  }\n\n  return result;\n}\n\n\nfunction isNegativeZero(number) {\n  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);\n}\n\n\nvar isNothing_1      = isNothing;\nvar isObject_1       = isObject;\nvar toArray_1        = toArray;\nvar repeat_1         = repeat;\nvar isNegativeZero_1 = isNegativeZero;\nvar extend_1         = extend;\n\nvar common = {\n\tisNothing: isNothing_1,\n\tisObject: isObject_1,\n\ttoArray: toArray_1,\n\trepeat: repeat_1,\n\tisNegativeZero: isNegativeZero_1,\n\textend: extend_1\n};\n\n// YAML error class. http://stackoverflow.com/questions/8458984\n\n\nfunction formatError(exception, compact) {\n  var where = '', message = exception.reason || '(unknown reason)';\n\n  if (!exception.mark) return message;\n\n  if (exception.mark.name) {\n    where += 'in \"' + exception.mark.name + '\" ';\n  }\n\n  where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';\n\n  if (!compact && exception.mark.snippet) {\n    where += '\\n\\n' + exception.mark.snippet;\n  }\n\n  return message + ' ' + where;\n}\n\n\nfunction YAMLException$1(reason, mark) {\n  // Super constructor\n  Error.call(this);\n\n  this.name = 'YAMLException';\n  this.reason = reason;\n  this.mark = mark;\n  this.message = formatError(this, false);\n\n  // Include stack trace in error object\n  if (Error.captureStackTrace) {\n    // Chrome and NodeJS\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    // FF, IE 10+ and Safari 6+. Fallback for others\n    this.stack = (new Error()).stack || '';\n  }\n}\n\n\n// Inherit from Error\nYAMLException$1.prototype = Object.create(Error.prototype);\nYAMLException$1.prototype.constructor = YAMLException$1;\n\n\nYAMLException$1.prototype.toString = function toString(compact) {\n  return this.name + ': ' + formatError(this, compact);\n};\n\n\nvar exception = YAMLException$1;\n\n// get snippet for a single line, respecting maxLength\nfunction getLine(buffer, lineStart, lineEnd, position, maxLineLength) {\n  var head = '';\n  var tail = '';\n  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;\n\n  if (position - lineStart > maxHalfLength) {\n    head = ' ... ';\n    lineStart = position - maxHalfLength + head.length;\n  }\n\n  if (lineEnd - position > maxHalfLength) {\n    tail = ' ...';\n    lineEnd = position + maxHalfLength - tail.length;\n  }\n\n  return {\n    str: head + buffer.slice(lineStart, lineEnd).replace(/\\t/g, 'â†’') + tail,\n    pos: position - lineStart + head.length // relative position\n  };\n}\n\n\nfunction padStart(string, max) {\n  return common.repeat(' ', max - string.length) + string;\n}\n\n\nfunction makeSnippet(mark, options) {\n  options = Object.create(options || null);\n\n  if (!mark.buffer) return null;\n\n  if (!options.maxLength) options.maxLength = 79;\n  if (typeof options.indent      !== 'number') options.indent      = 1;\n  if (typeof options.linesBefore !== 'number') options.linesBefore = 3;\n  if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;\n\n  var re = /\\r?\\n|\\r|\\0/g;\n  var lineStarts = [ 0 ];\n  var lineEnds = [];\n  var match;\n  var foundLineNo = -1;\n\n  while ((match = re.exec(mark.buffer))) {\n    lineEnds.push(match.index);\n    lineStarts.push(match.index + match[0].length);\n\n    if (mark.position <= match.index && foundLineNo < 0) {\n      foundLineNo = lineStarts.length - 2;\n    }\n  }\n\n  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;\n\n  var result = '', i, line;\n  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;\n  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);\n\n  for (i = 1; i <= options.linesBefore; i++) {\n    if (foundLineNo - i < 0) break;\n    line = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo - i],\n      lineEnds[foundLineNo - i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),\n      maxLineLength\n    );\n    result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n' + result;\n  }\n\n  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);\n  result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +\n    ' | ' + line.str + '\\n';\n  result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\\n';\n\n  for (i = 1; i <= options.linesAfter; i++) {\n    if (foundLineNo + i >= lineEnds.length) break;\n    line = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo + i],\n      lineEnds[foundLineNo + i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),\n      maxLineLength\n    );\n    result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n';\n  }\n\n  return result.replace(/\\n$/, '');\n}\n\n\nvar snippet = makeSnippet;\n\nvar TYPE_CONSTRUCTOR_OPTIONS = [\n  'kind',\n  'multi',\n  'resolve',\n  'construct',\n  'instanceOf',\n  'predicate',\n  'represent',\n  'representName',\n  'defaultStyle',\n  'styleAliases'\n];\n\nvar YAML_NODE_KINDS = [\n  'scalar',\n  'sequence',\n  'mapping'\n];\n\nfunction compileStyleAliases(map) {\n  var result = {};\n\n  if (map !== null) {\n    Object.keys(map).forEach(function (style) {\n      map[style].forEach(function (alias) {\n        result[String(alias)] = style;\n      });\n    });\n  }\n\n  return result;\n}\n\nfunction Type$1(tag, options) {\n  options = options || {};\n\n  Object.keys(options).forEach(function (name) {\n    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n      throw new exception('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n    }\n  });\n\n  // TODO: Add tag format check.\n  this.options       = options; // keep original options in case user wants to extend this type later\n  this.tag           = tag;\n  this.kind          = options['kind']          || null;\n  this.resolve       = options['resolve']       || function () { return true; };\n  this.construct     = options['construct']     || function (data) { return data; };\n  this.instanceOf    = options['instanceOf']    || null;\n  this.predicate     = options['predicate']     || null;\n  this.represent     = options['represent']     || null;\n  this.representName = options['representName'] || null;\n  this.defaultStyle  = options['defaultStyle']  || null;\n  this.multi         = options['multi']         || false;\n  this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);\n\n  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n    throw new exception('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n  }\n}\n\nvar type = Type$1;\n\n/*eslint-disable max-len*/\n\n\n\n\n\nfunction compileList(schema, name) {\n  var result = [];\n\n  schema[name].forEach(function (currentType) {\n    var newIndex = result.length;\n\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag &&\n          previousType.kind === currentType.kind &&\n          previousType.multi === currentType.multi) {\n\n        newIndex = previousIndex;\n      }\n    });\n\n    result[newIndex] = currentType;\n  });\n\n  return result;\n}\n\n\nfunction compileMap(/* lists... */) {\n  var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {},\n        multi: {\n          scalar: [],\n          sequence: [],\n          mapping: [],\n          fallback: []\n        }\n      }, index, length;\n\n  function collectType(type) {\n    if (type.multi) {\n      result.multi[type.kind].push(type);\n      result.multi['fallback'].push(type);\n    } else {\n      result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n    }\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n  return result;\n}\n\n\nfunction Schema$1(definition) {\n  return this.extend(definition);\n}\n\n\nSchema$1.prototype.extend = function extend(definition) {\n  var implicit = [];\n  var explicit = [];\n\n  if (definition instanceof type) {\n    // Schema.extend(type)\n    explicit.push(definition);\n\n  } else if (Array.isArray(definition)) {\n    // Schema.extend([ type1, type2, ... ])\n    explicit = explicit.concat(definition);\n\n  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\n    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })\n    if (definition.implicit) implicit = implicit.concat(definition.implicit);\n    if (definition.explicit) explicit = explicit.concat(definition.explicit);\n\n  } else {\n    throw new exception('Schema.extend argument should be a Type, [ Type ], ' +\n      'or a schema definition ({ implicit: [...], explicit: [...] })');\n  }\n\n  implicit.forEach(function (type$1) {\n    if (!(type$1 instanceof type)) {\n      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n\n    if (type$1.loadKind && type$1.loadKind !== 'scalar') {\n      throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n\n    if (type$1.multi) {\n      throw new exception('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');\n    }\n  });\n\n  explicit.forEach(function (type$1) {\n    if (!(type$1 instanceof type)) {\n      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n  });\n\n  var result = Object.create(Schema$1.prototype);\n\n  result.implicit = (this.implicit || []).concat(implicit);\n  result.explicit = (this.explicit || []).concat(explicit);\n\n  result.compiledImplicit = compileList(result, 'implicit');\n  result.compiledExplicit = compileList(result, 'explicit');\n  result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);\n\n  return result;\n};\n\n\nvar schema = Schema$1;\n\nvar str = new type('tag:yaml.org,2002:str', {\n  kind: 'scalar',\n  construct: function (data) { return data !== null ? data : ''; }\n});\n\nvar seq = new type('tag:yaml.org,2002:seq', {\n  kind: 'sequence',\n  construct: function (data) { return data !== null ? data : []; }\n});\n\nvar map = new type('tag:yaml.org,2002:map', {\n  kind: 'mapping',\n  construct: function (data) { return data !== null ? data : {}; }\n});\n\nvar failsafe = new schema({\n  explicit: [\n    str,\n    seq,\n    map\n  ]\n});\n\nfunction resolveYamlNull(data) {\n  if (data === null) return true;\n\n  var max = data.length;\n\n  return (max === 1 && data === '~') ||\n         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));\n}\n\nfunction constructYamlNull() {\n  return null;\n}\n\nfunction isNull(object) {\n  return object === null;\n}\n\nvar _null = new type('tag:yaml.org,2002:null', {\n  kind: 'scalar',\n  resolve: resolveYamlNull,\n  construct: constructYamlNull,\n  predicate: isNull,\n  represent: {\n    canonical: function () { return '~';    },\n    lowercase: function () { return 'null'; },\n    uppercase: function () { return 'NULL'; },\n    camelcase: function () { return 'Null'; },\n    empty:     function () { return '';     }\n  },\n  defaultStyle: 'lowercase'\n});\n\nfunction resolveYamlBoolean(data) {\n  if (data === null) return false;\n\n  var max = data.length;\n\n  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||\n         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));\n}\n\nfunction constructYamlBoolean(data) {\n  return data === 'true' ||\n         data === 'True' ||\n         data === 'TRUE';\n}\n\nfunction isBoolean(object) {\n  return Object.prototype.toString.call(object) === '[object Boolean]';\n}\n\nvar bool = new type('tag:yaml.org,2002:bool', {\n  kind: 'scalar',\n  resolve: resolveYamlBoolean,\n  construct: constructYamlBoolean,\n  predicate: isBoolean,\n  represent: {\n    lowercase: function (object) { return object ? 'true' : 'false'; },\n    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },\n    camelcase: function (object) { return object ? 'True' : 'False'; }\n  },\n  defaultStyle: 'lowercase'\n});\n\nfunction isHexCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||\n         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||\n         ((0x61/* a */ <= c) && (c <= 0x66/* f */));\n}\n\nfunction isOctCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));\n}\n\nfunction isDecCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));\n}\n\nfunction resolveYamlInteger(data) {\n  if (data === null) return false;\n\n  var max = data.length,\n      index = 0,\n      hasDigits = false,\n      ch;\n\n  if (!max) return false;\n\n  ch = data[index];\n\n  // sign\n  if (ch === '-' || ch === '+') {\n    ch = data[++index];\n  }\n\n  if (ch === '0') {\n    // 0\n    if (index + 1 === max) return true;\n    ch = data[++index];\n\n    // base 2, base 8, base 16\n\n    if (ch === 'b') {\n      // base 2\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (ch !== '0' && ch !== '1') return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'x') {\n      // base 16\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isHexCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'o') {\n      // base 8\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isOctCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n  }\n\n  // base 10 (except 0)\n\n  // value should not start with `_`;\n  if (ch === '_') return false;\n\n  for (; index < max; index++) {\n    ch = data[index];\n    if (ch === '_') continue;\n    if (!isDecCode(data.charCodeAt(index))) {\n      return false;\n    }\n    hasDigits = true;\n  }\n\n  // Should have digits and should not end with `_`\n  if (!hasDigits || ch === '_') return false;\n\n  return true;\n}\n\nfunction constructYamlInteger(data) {\n  var value = data, sign = 1, ch;\n\n  if (value.indexOf('_') !== -1) {\n    value = value.replace(/_/g, '');\n  }\n\n  ch = value[0];\n\n  if (ch === '-' || ch === '+') {\n    if (ch === '-') sign = -1;\n    value = value.slice(1);\n    ch = value[0];\n  }\n\n  if (value === '0') return 0;\n\n  if (ch === '0') {\n    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n    if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);\n    if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);\n  }\n\n  return sign * parseInt(value, 10);\n}\n\nfunction isInteger(object) {\n  return (Object.prototype.toString.call(object)) === '[object Number]' &&\n         (object % 1 === 0 && !common.isNegativeZero(object));\n}\n\nvar int = new type('tag:yaml.org,2002:int', {\n  kind: 'scalar',\n  resolve: resolveYamlInteger,\n  construct: constructYamlInteger,\n  predicate: isInteger,\n  represent: {\n    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },\n    octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },\n    decimal:     function (obj) { return obj.toString(10); },\n    /* eslint-disable max-len */\n    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }\n  },\n  defaultStyle: 'decimal',\n  styleAliases: {\n    binary:      [ 2,  'bin' ],\n    octal:       [ 8,  'oct' ],\n    decimal:     [ 10, 'dec' ],\n    hexadecimal: [ 16, 'hex' ]\n  }\n});\n\nvar YAML_FLOAT_PATTERN = new RegExp(\n  // 2.5e4, 2.5 and integers\n  '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n  // .2e4, .2\n  // special case, seems not from spec\n  '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n  // .inf\n  '|[-+]?\\\\.(?:inf|Inf|INF)' +\n  // .nan\n  '|\\\\.(?:nan|NaN|NAN))$');\n\nfunction resolveYamlFloat(data) {\n  if (data === null) return false;\n\n  if (!YAML_FLOAT_PATTERN.test(data) ||\n      // Quick hack to not allow integers end with `_`\n      // Probably should update regexp & check speed\n      data[data.length - 1] === '_') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlFloat(data) {\n  var value, sign;\n\n  value  = data.replace(/_/g, '').toLowerCase();\n  sign   = value[0] === '-' ? -1 : 1;\n\n  if ('+-'.indexOf(value[0]) >= 0) {\n    value = value.slice(1);\n  }\n\n  if (value === '.inf') {\n    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n  } else if (value === '.nan') {\n    return NaN;\n  }\n  return sign * parseFloat(value, 10);\n}\n\n\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\nfunction representYamlFloat(object, style) {\n  var res;\n\n  if (isNaN(object)) {\n    switch (style) {\n      case 'lowercase': return '.nan';\n      case 'uppercase': return '.NAN';\n      case 'camelcase': return '.NaN';\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '.inf';\n      case 'uppercase': return '.INF';\n      case 'camelcase': return '.Inf';\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '-.inf';\n      case 'uppercase': return '-.INF';\n      case 'camelcase': return '-.Inf';\n    }\n  } else if (common.isNegativeZero(object)) {\n    return '-0.0';\n  }\n\n  res = object.toString(10);\n\n  // JS stringifier can build scientific format without dots: 5e-100,\n  // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n}\n\nfunction isFloat(object) {\n  return (Object.prototype.toString.call(object) === '[object Number]') &&\n         (object % 1 !== 0 || common.isNegativeZero(object));\n}\n\nvar float = new type('tag:yaml.org,2002:float', {\n  kind: 'scalar',\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: 'lowercase'\n});\n\nvar json = failsafe.extend({\n  implicit: [\n    _null,\n    bool,\n    int,\n    float\n  ]\n});\n\nvar core = json;\n\nvar YAML_DATE_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9])'                    + // [2] month\n  '-([0-9][0-9])$');                   // [3] day\n\nvar YAML_TIMESTAMP_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9]?)'                   + // [2] month\n  '-([0-9][0-9]?)'                   + // [3] day\n  '(?:[Tt]|[ \\\\t]+)'                 + // ...\n  '([0-9][0-9]?)'                    + // [4] hour\n  ':([0-9][0-9])'                    + // [5] minute\n  ':([0-9][0-9])'                    + // [6] second\n  '(?:\\\\.([0-9]*))?'                 + // [7] fraction\n  '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute\n\nfunction resolveYamlTimestamp(data) {\n  if (data === null) return false;\n  if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n  return false;\n}\n\nfunction constructYamlTimestamp(data) {\n  var match, year, month, day, hour, minute, second, fraction = 0,\n      delta = null, tz_hour, tz_minute, date;\n\n  match = YAML_DATE_REGEXP.exec(data);\n  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n\n  if (match === null) throw new Error('Date resolve error');\n\n  // match: [1] year [2] month [3] day\n\n  year = +(match[1]);\n  month = +(match[2]) - 1; // JS month starts with 0\n  day = +(match[3]);\n\n  if (!match[4]) { // no hour\n    return new Date(Date.UTC(year, month, day));\n  }\n\n  // match: [4] hour [5] minute [6] second [7] fraction\n\n  hour = +(match[4]);\n  minute = +(match[5]);\n  second = +(match[6]);\n\n  if (match[7]) {\n    fraction = match[7].slice(0, 3);\n    while (fraction.length < 3) { // milli-seconds\n      fraction += '0';\n    }\n    fraction = +fraction;\n  }\n\n  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n  if (match[9]) {\n    tz_hour = +(match[10]);\n    tz_minute = +(match[11] || 0);\n    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n    if (match[9] === '-') delta = -delta;\n  }\n\n  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n\n  if (delta) date.setTime(date.getTime() - delta);\n\n  return date;\n}\n\nfunction representYamlTimestamp(object /*, style*/) {\n  return object.toISOString();\n}\n\nvar timestamp = new type('tag:yaml.org,2002:timestamp', {\n  kind: 'scalar',\n  resolve: resolveYamlTimestamp,\n  construct: constructYamlTimestamp,\n  instanceOf: Date,\n  represent: representYamlTimestamp\n});\n\nfunction resolveYamlMerge(data) {\n  return data === '<<' || data === null;\n}\n\nvar merge = new type('tag:yaml.org,2002:merge', {\n  kind: 'scalar',\n  resolve: resolveYamlMerge\n});\n\n/*eslint-disable no-bitwise*/\n\n\n\n\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n\n  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) continue;\n\n    // Fail on illegal characters\n    if (code < 0) return false;\n\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return (bitlen % 8) === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx, tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = (bits << 6) | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    result.push((bits >> 16) & 0xFF);\n    result.push((bits >> 8) & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push((bits >> 10) & 0xFF);\n    result.push((bits >> 2) & 0xFF);\n  } else if (tailbits === 12) {\n    result.push((bits >> 4) & 0xFF);\n  }\n\n  return new Uint8Array(result);\n}\n\nfunction representYamlBinary(object /*, style*/) {\n  var result = '', bits = 0, idx, tail,\n      max = object.length,\n      map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 3 === 0) && idx) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[(bits >> 18) & 0x3F];\n    result += map[(bits >> 12) & 0x3F];\n    result += map[(bits >> 6) & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[(bits >> 10) & 0x3F];\n    result += map[(bits >> 4) & 0x3F];\n    result += map[(bits << 2) & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[(bits >> 2) & 0x3F];\n    result += map[(bits << 4) & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(obj) {\n  return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';\n}\n\nvar binary = new type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n\nvar _hasOwnProperty$3 = Object.prototype.hasOwnProperty;\nvar _toString$2       = Object.prototype.toString;\n\nfunction resolveYamlOmap(data) {\n  if (data === null) return true;\n\n  var objectKeys = [], index, length, pair, pairKey, pairHasKey,\n      object = data;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    pairHasKey = false;\n\n    if (_toString$2.call(pair) !== '[object Object]') return false;\n\n    for (pairKey in pair) {\n      if (_hasOwnProperty$3.call(pair, pairKey)) {\n        if (!pairHasKey) pairHasKey = true;\n        else return false;\n      }\n    }\n\n    if (!pairHasKey) return false;\n\n    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n    else return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlOmap(data) {\n  return data !== null ? data : [];\n}\n\nvar omap = new type('tag:yaml.org,2002:omap', {\n  kind: 'sequence',\n  resolve: resolveYamlOmap,\n  construct: constructYamlOmap\n});\n\nvar _toString$1 = Object.prototype.toString;\n\nfunction resolveYamlPairs(data) {\n  if (data === null) return true;\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    if (_toString$1.call(pair) !== '[object Object]') return false;\n\n    keys = Object.keys(pair);\n\n    if (keys.length !== 1) return false;\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return true;\n}\n\nfunction constructYamlPairs(data) {\n  if (data === null) return [];\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    keys = Object.keys(pair);\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return result;\n}\n\nvar pairs = new type('tag:yaml.org,2002:pairs', {\n  kind: 'sequence',\n  resolve: resolveYamlPairs,\n  construct: constructYamlPairs\n});\n\nvar _hasOwnProperty$2 = Object.prototype.hasOwnProperty;\n\nfunction resolveYamlSet(data) {\n  if (data === null) return true;\n\n  var key, object = data;\n\n  for (key in object) {\n    if (_hasOwnProperty$2.call(object, key)) {\n      if (object[key] !== null) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constructYamlSet(data) {\n  return data !== null ? data : {};\n}\n\nvar set = new type('tag:yaml.org,2002:set', {\n  kind: 'mapping',\n  resolve: resolveYamlSet,\n  construct: constructYamlSet\n});\n\nvar _default = core.extend({\n  implicit: [\n    timestamp,\n    merge\n  ],\n  explicit: [\n    binary,\n    omap,\n    pairs,\n    set\n  ]\n});\n\n/*eslint-disable max-len,no-use-before-define*/\n\n\n\n\n\n\n\nvar _hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n\n\nvar CONTEXT_FLOW_IN   = 1;\nvar CONTEXT_FLOW_OUT  = 2;\nvar CONTEXT_BLOCK_IN  = 3;\nvar CONTEXT_BLOCK_OUT = 4;\n\n\nvar CHOMPING_CLIP  = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP  = 3;\n\n\nvar PATTERN_NON_PRINTABLE         = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS       = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI               = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction is_EOL(c) {\n  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);\n}\n\nfunction is_WHITE_SPACE(c) {\n  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);\n}\n\nfunction is_WS_OR_EOL(c) {\n  return (c === 0x09/* Tab */) ||\n         (c === 0x20/* Space */) ||\n         (c === 0x0A/* LF */) ||\n         (c === 0x0D/* CR */);\n}\n\nfunction is_FLOW_INDICATOR(c) {\n  return c === 0x2C/* , */ ||\n         c === 0x5B/* [ */ ||\n         c === 0x5D/* ] */ ||\n         c === 0x7B/* { */ ||\n         c === 0x7D/* } */;\n}\n\nfunction fromHexCode(c) {\n  var lc;\n\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  /*eslint-disable no-bitwise*/\n  lc = c | 0x20;\n\n  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {\n    return lc - 0x61 + 10;\n  }\n\n  return -1;\n}\n\nfunction escapedHexLen(c) {\n  if (c === 0x78/* x */) { return 2; }\n  if (c === 0x75/* u */) { return 4; }\n  if (c === 0x55/* U */) { return 8; }\n  return 0;\n}\n\nfunction fromDecimalCode(c) {\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  return -1;\n}\n\nfunction simpleEscapeSequence(c) {\n  /* eslint-disable indent */\n  return (c === 0x30/* 0 */) ? '\\x00' :\n        (c === 0x61/* a */) ? '\\x07' :\n        (c === 0x62/* b */) ? '\\x08' :\n        (c === 0x74/* t */) ? '\\x09' :\n        (c === 0x09/* Tab */) ? '\\x09' :\n        (c === 0x6E/* n */) ? '\\x0A' :\n        (c === 0x76/* v */) ? '\\x0B' :\n        (c === 0x66/* f */) ? '\\x0C' :\n        (c === 0x72/* r */) ? '\\x0D' :\n        (c === 0x65/* e */) ? '\\x1B' :\n        (c === 0x20/* Space */) ? ' ' :\n        (c === 0x22/* \" */) ? '\\x22' :\n        (c === 0x2F/* / */) ? '/' :\n        (c === 0x5C/* \\ */) ? '\\x5C' :\n        (c === 0x4E/* N */) ? '\\x85' :\n        (c === 0x5F/* _ */) ? '\\xA0' :\n        (c === 0x4C/* L */) ? '\\u2028' :\n        (c === 0x50/* P */) ? '\\u2029' : '';\n}\n\nfunction charFromCodepoint(c) {\n  if (c <= 0xFFFF) {\n    return String.fromCharCode(c);\n  }\n  // Encode UTF-16 surrogate pair\n  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n  return String.fromCharCode(\n    ((c - 0x010000) >> 10) + 0xD800,\n    ((c - 0x010000) & 0x03FF) + 0xDC00\n  );\n}\n\nvar simpleEscapeCheck = new Array(256); // integer, for fast access\nvar simpleEscapeMap = new Array(256);\nfor (var i = 0; i < 256; i++) {\n  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n  simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\n\n\nfunction State$1(input, options) {\n  this.input = input;\n\n  this.filename  = options['filename']  || null;\n  this.schema    = options['schema']    || _default;\n  this.onWarning = options['onWarning'] || null;\n  // (Hidden) Remove? makes the loader to expect YAML 1.1 documents\n  // if such documents have no explicit %YAML directive\n  this.legacy    = options['legacy']    || false;\n\n  this.json      = options['json']      || false;\n  this.listener  = options['listener']  || null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.typeMap       = this.schema.compiledTypeMap;\n\n  this.length     = input.length;\n  this.position   = 0;\n  this.line       = 0;\n  this.lineStart  = 0;\n  this.lineIndent = 0;\n\n  // position of first leading tab in the current line,\n  // used to make sure there are no tabs in the indentation\n  this.firstTabInLine = -1;\n\n  this.documents = [];\n\n  /*\n  this.version;\n  this.checkLineBreaks;\n  this.tagMap;\n  this.anchorMap;\n  this.tag;\n  this.anchor;\n  this.kind;\n  this.result;*/\n\n}\n\n\nfunction generateError(state, message) {\n  var mark = {\n    name:     state.filename,\n    buffer:   state.input.slice(0, -1), // omit trailing \\0\n    position: state.position,\n    line:     state.line,\n    column:   state.position - state.lineStart\n  };\n\n  mark.snippet = snippet(mark);\n\n  return new exception(message, mark);\n}\n\nfunction throwError(state, message) {\n  throw generateError(state, message);\n}\n\nfunction throwWarning(state, message) {\n  if (state.onWarning) {\n    state.onWarning.call(null, generateError(state, message));\n  }\n}\n\n\nvar directiveHandlers = {\n\n  YAML: function handleYamlDirective(state, name, args) {\n\n    var match, major, minor;\n\n    if (state.version !== null) {\n      throwError(state, 'duplication of %YAML directive');\n    }\n\n    if (args.length !== 1) {\n      throwError(state, 'YAML directive accepts exactly one argument');\n    }\n\n    match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n    if (match === null) {\n      throwError(state, 'ill-formed argument of the YAML directive');\n    }\n\n    major = parseInt(match[1], 10);\n    minor = parseInt(match[2], 10);\n\n    if (major !== 1) {\n      throwError(state, 'unacceptable YAML version of the document');\n    }\n\n    state.version = args[0];\n    state.checkLineBreaks = (minor < 2);\n\n    if (minor !== 1 && minor !== 2) {\n      throwWarning(state, 'unsupported YAML version of the document');\n    }\n  },\n\n  TAG: function handleTagDirective(state, name, args) {\n\n    var handle, prefix;\n\n    if (args.length !== 2) {\n      throwError(state, 'TAG directive accepts exactly two arguments');\n    }\n\n    handle = args[0];\n    prefix = args[1];\n\n    if (!PATTERN_TAG_HANDLE.test(handle)) {\n      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n    }\n\n    if (_hasOwnProperty$1.call(state.tagMap, handle)) {\n      throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n    }\n\n    if (!PATTERN_TAG_URI.test(prefix)) {\n      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n    }\n\n    try {\n      prefix = decodeURIComponent(prefix);\n    } catch (err) {\n      throwError(state, 'tag prefix is malformed: ' + prefix);\n    }\n\n    state.tagMap[handle] = prefix;\n  }\n};\n\n\nfunction captureSegment(state, start, end, checkJson) {\n  var _position, _length, _character, _result;\n\n  if (start < end) {\n    _result = state.input.slice(start, end);\n\n    if (checkJson) {\n      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n        _character = _result.charCodeAt(_position);\n        if (!(_character === 0x09 ||\n              (0x20 <= _character && _character <= 0x10FFFF))) {\n          throwError(state, 'expected valid JSON character');\n        }\n      }\n    } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n      throwError(state, 'the stream contains non-printable characters');\n    }\n\n    state.result += _result;\n  }\n}\n\nfunction mergeMappings(state, destination, source, overridableKeys) {\n  var sourceKeys, key, index, quantity;\n\n  if (!common.isObject(source)) {\n    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n  }\n\n  sourceKeys = Object.keys(source);\n\n  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n    key = sourceKeys[index];\n\n    if (!_hasOwnProperty$1.call(destination, key)) {\n      destination[key] = source[key];\n      overridableKeys[key] = true;\n    }\n  }\n}\n\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,\n  startLine, startLineStart, startPos) {\n\n  var index, quantity;\n\n  // The output is a plain object here, so keys can only be strings.\n  // We need to convert keyNode to a string, but doing so can hang the process\n  // (deeply nested arrays that explode exponentially using aliases).\n  if (Array.isArray(keyNode)) {\n    keyNode = Array.prototype.slice.call(keyNode);\n\n    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n      if (Array.isArray(keyNode[index])) {\n        throwError(state, 'nested arrays are not supported inside keys');\n      }\n\n      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n        keyNode[index] = '[object Object]';\n      }\n    }\n  }\n\n  // Avoid code execution in load() via toString property\n  // (still use its own toString for arrays, timestamps,\n  // and whatever user schema extensions happen to have @@toStringTag)\n  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n    keyNode = '[object Object]';\n  }\n\n\n  keyNode = String(keyNode);\n\n  if (_result === null) {\n    _result = {};\n  }\n\n  if (keyTag === 'tag:yaml.org,2002:merge') {\n    if (Array.isArray(valueNode)) {\n      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n        mergeMappings(state, _result, valueNode[index], overridableKeys);\n      }\n    } else {\n      mergeMappings(state, _result, valueNode, overridableKeys);\n    }\n  } else {\n    if (!state.json &&\n        !_hasOwnProperty$1.call(overridableKeys, keyNode) &&\n        _hasOwnProperty$1.call(_result, keyNode)) {\n      state.line = startLine || state.line;\n      state.lineStart = startLineStart || state.lineStart;\n      state.position = startPos || state.position;\n      throwError(state, 'duplicated mapping key');\n    }\n\n    // used for this specific key only because Object.defineProperty is slow\n    if (keyNode === '__proto__') {\n      Object.defineProperty(_result, keyNode, {\n        configurable: true,\n        enumerable: true,\n        writable: true,\n        value: valueNode\n      });\n    } else {\n      _result[keyNode] = valueNode;\n    }\n    delete overridableKeys[keyNode];\n  }\n\n  return _result;\n}\n\nfunction readLineBreak(state) {\n  var ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x0A/* LF */) {\n    state.position++;\n  } else if (ch === 0x0D/* CR */) {\n    state.position++;\n    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {\n      state.position++;\n    }\n  } else {\n    throwError(state, 'a line break is expected');\n  }\n\n  state.line += 1;\n  state.lineStart = state.position;\n  state.firstTabInLine = -1;\n}\n\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n  var lineBreaks = 0,\n      ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    while (is_WHITE_SPACE(ch)) {\n      if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {\n        state.firstTabInLine = state.position;\n      }\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (allowComments && ch === 0x23/* # */) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);\n    }\n\n    if (is_EOL(ch)) {\n      readLineBreak(state);\n\n      ch = state.input.charCodeAt(state.position);\n      lineBreaks++;\n      state.lineIndent = 0;\n\n      while (ch === 0x20/* Space */) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n    throwWarning(state, 'deficient indentation');\n  }\n\n  return lineBreaks;\n}\n\nfunction testDocumentSeparator(state) {\n  var _position = state.position,\n      ch;\n\n  ch = state.input.charCodeAt(_position);\n\n  // Condition state.position === state.lineStart is tested\n  // in parent on each call, for efficiency. No needs to test here again.\n  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&\n      ch === state.input.charCodeAt(_position + 1) &&\n      ch === state.input.charCodeAt(_position + 2)) {\n\n    _position += 3;\n\n    ch = state.input.charCodeAt(_position);\n\n    if (ch === 0 || is_WS_OR_EOL(ch)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction writeFoldedLines(state, count) {\n  if (count === 1) {\n    state.result += ' ';\n  } else if (count > 1) {\n    state.result += common.repeat('\\n', count - 1);\n  }\n}\n\n\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n  var preceding,\n      following,\n      captureStart,\n      captureEnd,\n      hasPendingContent,\n      _line,\n      _lineStart,\n      _lineIndent,\n      _kind = state.kind,\n      _result = state.result,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (is_WS_OR_EOL(ch)      ||\n      is_FLOW_INDICATOR(ch) ||\n      ch === 0x23/* # */    ||\n      ch === 0x26/* & */    ||\n      ch === 0x2A/* * */    ||\n      ch === 0x21/* ! */    ||\n      ch === 0x7C/* | */    ||\n      ch === 0x3E/* > */    ||\n      ch === 0x27/* ' */    ||\n      ch === 0x22/* \" */    ||\n      ch === 0x25/* % */    ||\n      ch === 0x40/* @ */    ||\n      ch === 0x60/* ` */) {\n    return false;\n  }\n\n  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (is_WS_OR_EOL(following) ||\n        withinFlowCollection && is_FLOW_INDICATOR(following)) {\n      return false;\n    }\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  captureStart = captureEnd = state.position;\n  hasPendingContent = false;\n\n  while (ch !== 0) {\n    if (ch === 0x3A/* : */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following) ||\n          withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        break;\n      }\n\n    } else if (ch === 0x23/* # */) {\n      preceding = state.input.charCodeAt(state.position - 1);\n\n      if (is_WS_OR_EOL(preceding)) {\n        break;\n      }\n\n    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||\n               withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n      break;\n\n    } else if (is_EOL(ch)) {\n      _line = state.line;\n      _lineStart = state.lineStart;\n      _lineIndent = state.lineIndent;\n      skipSeparationSpace(state, false, -1);\n\n      if (state.lineIndent >= nodeIndent) {\n        hasPendingContent = true;\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      } else {\n        state.position = captureEnd;\n        state.line = _line;\n        state.lineStart = _lineStart;\n        state.lineIndent = _lineIndent;\n        break;\n      }\n    }\n\n    if (hasPendingContent) {\n      captureSegment(state, captureStart, captureEnd, false);\n      writeFoldedLines(state, state.line - _line);\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n    }\n\n    if (!is_WHITE_SPACE(ch)) {\n      captureEnd = state.position + 1;\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  captureSegment(state, captureStart, captureEnd, false);\n\n  if (state.result) {\n    return true;\n  }\n\n  state.kind = _kind;\n  state.result = _result;\n  return false;\n}\n\nfunction readSingleQuotedScalar(state, nodeIndent) {\n  var ch,\n      captureStart, captureEnd;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x27/* ' */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x27/* ' */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (ch === 0x27/* ' */) {\n        captureStart = state.position;\n        state.position++;\n        captureEnd = state.position;\n      } else {\n        return true;\n      }\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a single quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a single quoted scalar');\n}\n\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n  var captureStart,\n      captureEnd,\n      hexLength,\n      hexResult,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x22/* \" */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x22/* \" */) {\n      captureSegment(state, captureStart, state.position, true);\n      state.position++;\n      return true;\n\n    } else if (ch === 0x5C/* \\ */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (is_EOL(ch)) {\n        skipSeparationSpace(state, false, nodeIndent);\n\n        // TODO: rework to inline fn with no type cast?\n      } else if (ch < 256 && simpleEscapeCheck[ch]) {\n        state.result += simpleEscapeMap[ch];\n        state.position++;\n\n      } else if ((tmp = escapedHexLen(ch)) > 0) {\n        hexLength = tmp;\n        hexResult = 0;\n\n        for (; hexLength > 0; hexLength--) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if ((tmp = fromHexCode(ch)) >= 0) {\n            hexResult = (hexResult << 4) + tmp;\n\n          } else {\n            throwError(state, 'expected hexadecimal character');\n          }\n        }\n\n        state.result += charFromCodepoint(hexResult);\n\n        state.position++;\n\n      } else {\n        throwError(state, 'unknown escape sequence');\n      }\n\n      captureStart = captureEnd = state.position;\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a double quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a double quoted scalar');\n}\n\nfunction readFlowCollection(state, nodeIndent) {\n  var readNext = true,\n      _line,\n      _lineStart,\n      _pos,\n      _tag     = state.tag,\n      _result,\n      _anchor  = state.anchor,\n      following,\n      terminator,\n      isPair,\n      isExplicitPair,\n      isMapping,\n      overridableKeys = Object.create(null),\n      keyNode,\n      keyTag,\n      valueNode,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x5B/* [ */) {\n    terminator = 0x5D;/* ] */\n    isMapping = false;\n    _result = [];\n  } else if (ch === 0x7B/* { */) {\n    terminator = 0x7D;/* } */\n    isMapping = true;\n    _result = {};\n  } else {\n    return false;\n  }\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  while (ch !== 0) {\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === terminator) {\n      state.position++;\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = isMapping ? 'mapping' : 'sequence';\n      state.result = _result;\n      return true;\n    } else if (!readNext) {\n      throwError(state, 'missed comma between flow collection entries');\n    } else if (ch === 0x2C/* , */) {\n      // \"flow collection entries can never be completely empty\", as per YAML 1.2, section 7.4\n      throwError(state, \"expected the node content, but found ','\");\n    }\n\n    keyTag = keyNode = valueNode = null;\n    isPair = isExplicitPair = false;\n\n    if (ch === 0x3F/* ? */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following)) {\n        isPair = isExplicitPair = true;\n        state.position++;\n        skipSeparationSpace(state, true, nodeIndent);\n      }\n    }\n\n    _line = state.line; // Save the current line.\n    _lineStart = state.lineStart;\n    _pos = state.position;\n    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n    keyTag = state.tag;\n    keyNode = state.result;\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {\n      isPair = true;\n      ch = state.input.charCodeAt(++state.position);\n      skipSeparationSpace(state, true, nodeIndent);\n      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n      valueNode = state.result;\n    }\n\n    if (isMapping) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);\n    } else if (isPair) {\n      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));\n    } else {\n      _result.push(keyNode);\n    }\n\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x2C/* , */) {\n      readNext = true;\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      readNext = false;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a flow collection');\n}\n\nfunction readBlockScalar(state, nodeIndent) {\n  var captureStart,\n      folding,\n      chomping       = CHOMPING_CLIP,\n      didReadContent = false,\n      detectedIndent = false,\n      textIndent     = nodeIndent,\n      emptyLines     = 0,\n      atMoreIndented = false,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x7C/* | */) {\n    folding = false;\n  } else if (ch === 0x3E/* > */) {\n    folding = true;\n  } else {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n\n  while (ch !== 0) {\n    ch = state.input.charCodeAt(++state.position);\n\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      if (CHOMPING_CLIP === chomping) {\n        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;\n      } else {\n        throwError(state, 'repeat of a chomping mode identifier');\n      }\n\n    } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n      if (tmp === 0) {\n        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n      } else if (!detectedIndent) {\n        textIndent = nodeIndent + tmp - 1;\n        detectedIndent = true;\n      } else {\n        throwError(state, 'repeat of an indentation width identifier');\n      }\n\n    } else {\n      break;\n    }\n  }\n\n  if (is_WHITE_SPACE(ch)) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (is_WHITE_SPACE(ch));\n\n    if (ch === 0x23/* # */) {\n      do { ch = state.input.charCodeAt(++state.position); }\n      while (!is_EOL(ch) && (ch !== 0));\n    }\n  }\n\n  while (ch !== 0) {\n    readLineBreak(state);\n    state.lineIndent = 0;\n\n    ch = state.input.charCodeAt(state.position);\n\n    while ((!detectedIndent || state.lineIndent < textIndent) &&\n           (ch === 0x20/* Space */)) {\n      state.lineIndent++;\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (!detectedIndent && state.lineIndent > textIndent) {\n      textIndent = state.lineIndent;\n    }\n\n    if (is_EOL(ch)) {\n      emptyLines++;\n      continue;\n    }\n\n    // End of the scalar.\n    if (state.lineIndent < textIndent) {\n\n      // Perform the chomping.\n      if (chomping === CHOMPING_KEEP) {\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n      } else if (chomping === CHOMPING_CLIP) {\n        if (didReadContent) { // i.e. only if the scalar is not empty.\n          state.result += '\\n';\n        }\n      }\n\n      // Break this `while` cycle and go to the funciton's epilogue.\n      break;\n    }\n\n    // Folded style: use fancy rules to handle line breaks.\n    if (folding) {\n\n      // Lines starting with white space characters (more-indented lines) are not folded.\n      if (is_WHITE_SPACE(ch)) {\n        atMoreIndented = true;\n        // except for the first content line (cf. Example 8.1)\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n\n      // End of more-indented block.\n      } else if (atMoreIndented) {\n        atMoreIndented = false;\n        state.result += common.repeat('\\n', emptyLines + 1);\n\n      // Just one line break - perceive as the same line.\n      } else if (emptyLines === 0) {\n        if (didReadContent) { // i.e. only if we have already read some scalar content.\n          state.result += ' ';\n        }\n\n      // Several line breaks - perceive as different lines.\n      } else {\n        state.result += common.repeat('\\n', emptyLines);\n      }\n\n    // Literal style: just add exact number of line breaks between content lines.\n    } else {\n      // Keep all line breaks except the header line break.\n      state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n    }\n\n    didReadContent = true;\n    detectedIndent = true;\n    emptyLines = 0;\n    captureStart = state.position;\n\n    while (!is_EOL(ch) && (ch !== 0)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    captureSegment(state, captureStart, state.position, false);\n  }\n\n  return true;\n}\n\nfunction readBlockSequence(state, nodeIndent) {\n  var _line,\n      _tag      = state.tag,\n      _anchor   = state.anchor,\n      _result   = [],\n      following,\n      detected  = false,\n      ch;\n\n  // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    if (ch !== 0x2D/* - */) {\n      break;\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (!is_WS_OR_EOL(following)) {\n      break;\n    }\n\n    detected = true;\n    state.position++;\n\n    if (skipSeparationSpace(state, true, -1)) {\n      if (state.lineIndent <= nodeIndent) {\n        _result.push(null);\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n    _result.push(state.result);\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a sequence entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'sequence';\n    state.result = _result;\n    return true;\n  }\n  return false;\n}\n\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n  var following,\n      allowCompact,\n      _line,\n      _keyLine,\n      _keyLineStart,\n      _keyPos,\n      _tag          = state.tag,\n      _anchor       = state.anchor,\n      _result       = {},\n      overridableKeys = Object.create(null),\n      keyTag        = null,\n      keyNode       = null,\n      valueNode     = null,\n      atExplicitKey = false,\n      detected      = false,\n      ch;\n\n  // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (!atExplicitKey && state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n    _line = state.line; // Save the current line.\n\n    //\n    // Explicit notation case. There are two separate blocks:\n    // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n    //\n    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {\n\n      if (ch === 0x3F/* ? */) {\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n          keyTag = keyNode = valueNode = null;\n        }\n\n        detected = true;\n        atExplicitKey = true;\n        allowCompact = true;\n\n      } else if (atExplicitKey) {\n        // i.e. 0x3A/* : */ === character after the explicit key.\n        atExplicitKey = false;\n        allowCompact = true;\n\n      } else {\n        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n      }\n\n      state.position += 1;\n      ch = following;\n\n    //\n    // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n    //\n    } else {\n      _keyLine = state.line;\n      _keyLineStart = state.lineStart;\n      _keyPos = state.position;\n\n      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n        // Neither implicit nor explicit notation.\n        // Reading is done. Go to the epilogue.\n        break;\n      }\n\n      if (state.line === _line) {\n        ch = state.input.charCodeAt(state.position);\n\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (ch === 0x3A/* : */) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if (!is_WS_OR_EOL(ch)) {\n            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n          }\n\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n            keyTag = keyNode = valueNode = null;\n          }\n\n          detected = true;\n          atExplicitKey = false;\n          allowCompact = false;\n          keyTag = state.tag;\n          keyNode = state.result;\n\n        } else if (detected) {\n          throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n\n      } else if (detected) {\n        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n\n      } else {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        return true; // Keep the result of `composeNode`.\n      }\n    }\n\n    //\n    // Common reading code for both explicit and implicit notations.\n    //\n    if (state.line === _line || state.lineIndent > nodeIndent) {\n      if (atExplicitKey) {\n        _keyLine = state.line;\n        _keyLineStart = state.lineStart;\n        _keyPos = state.position;\n      }\n\n      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n        if (atExplicitKey) {\n          keyNode = state.result;\n        } else {\n          valueNode = state.result;\n        }\n      }\n\n      if (!atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);\n        keyTag = keyNode = valueNode = null;\n      }\n\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n    }\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a mapping entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  //\n  // Epilogue.\n  //\n\n  // Special case: last mapping's node contains only the key in explicit notation.\n  if (atExplicitKey) {\n    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n  }\n\n  // Expose the resulting mapping.\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'mapping';\n    state.result = _result;\n  }\n\n  return detected;\n}\n\nfunction readTagProperty(state) {\n  var _position,\n      isVerbatim = false,\n      isNamed    = false,\n      tagHandle,\n      tagName,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x21/* ! */) return false;\n\n  if (state.tag !== null) {\n    throwError(state, 'duplication of a tag property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  if (ch === 0x3C/* < */) {\n    isVerbatim = true;\n    ch = state.input.charCodeAt(++state.position);\n\n  } else if (ch === 0x21/* ! */) {\n    isNamed = true;\n    tagHandle = '!!';\n    ch = state.input.charCodeAt(++state.position);\n\n  } else {\n    tagHandle = '!';\n  }\n\n  _position = state.position;\n\n  if (isVerbatim) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (ch !== 0 && ch !== 0x3E/* > */);\n\n    if (state.position < state.length) {\n      tagName = state.input.slice(_position, state.position);\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      throwError(state, 'unexpected end of the stream within a verbatim tag');\n    }\n  } else {\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n\n      if (ch === 0x21/* ! */) {\n        if (!isNamed) {\n          tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n            throwError(state, 'named tag handle cannot contain such characters');\n          }\n\n          isNamed = true;\n          _position = state.position + 1;\n        } else {\n          throwError(state, 'tag suffix cannot contain exclamation marks');\n        }\n      }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    tagName = state.input.slice(_position, state.position);\n\n    if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n      throwError(state, 'tag suffix cannot contain flow indicator characters');\n    }\n  }\n\n  if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n    throwError(state, 'tag name cannot contain such characters: ' + tagName);\n  }\n\n  try {\n    tagName = decodeURIComponent(tagName);\n  } catch (err) {\n    throwError(state, 'tag name is malformed: ' + tagName);\n  }\n\n  if (isVerbatim) {\n    state.tag = tagName;\n\n  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {\n    state.tag = state.tagMap[tagHandle] + tagName;\n\n  } else if (tagHandle === '!') {\n    state.tag = '!' + tagName;\n\n  } else if (tagHandle === '!!') {\n    state.tag = 'tag:yaml.org,2002:' + tagName;\n\n  } else {\n    throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n  }\n\n  return true;\n}\n\nfunction readAnchorProperty(state) {\n  var _position,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x26/* & */) return false;\n\n  if (state.anchor !== null) {\n    throwError(state, 'duplication of an anchor property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an anchor node must contain at least one character');\n  }\n\n  state.anchor = state.input.slice(_position, state.position);\n  return true;\n}\n\nfunction readAlias(state) {\n  var _position, alias,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x2A/* * */) return false;\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an alias node must contain at least one character');\n  }\n\n  alias = state.input.slice(_position, state.position);\n\n  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {\n    throwError(state, 'unidentified alias \"' + alias + '\"');\n  }\n\n  state.result = state.anchorMap[alias];\n  skipSeparationSpace(state, true, -1);\n  return true;\n}\n\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n  var allowBlockStyles,\n      allowBlockScalars,\n      allowBlockCollections,\n      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent\n      atNewLine  = false,\n      hasContent = false,\n      typeIndex,\n      typeQuantity,\n      typeList,\n      type,\n      flowIndent,\n      blockIndent;\n\n  if (state.listener !== null) {\n    state.listener('open', state);\n  }\n\n  state.tag    = null;\n  state.anchor = null;\n  state.kind   = null;\n  state.result = null;\n\n  allowBlockStyles = allowBlockScalars = allowBlockCollections =\n    CONTEXT_BLOCK_OUT === nodeContext ||\n    CONTEXT_BLOCK_IN  === nodeContext;\n\n  if (allowToSeek) {\n    if (skipSeparationSpace(state, true, -1)) {\n      atNewLine = true;\n\n      if (state.lineIndent > parentIndent) {\n        indentStatus = 1;\n      } else if (state.lineIndent === parentIndent) {\n        indentStatus = 0;\n      } else if (state.lineIndent < parentIndent) {\n        indentStatus = -1;\n      }\n    }\n  }\n\n  if (indentStatus === 1) {\n    while (readTagProperty(state) || readAnchorProperty(state)) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n        allowBlockCollections = allowBlockStyles;\n\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      } else {\n        allowBlockCollections = false;\n      }\n    }\n  }\n\n  if (allowBlockCollections) {\n    allowBlockCollections = atNewLine || allowCompact;\n  }\n\n  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n      flowIndent = parentIndent;\n    } else {\n      flowIndent = parentIndent + 1;\n    }\n\n    blockIndent = state.position - state.lineStart;\n\n    if (indentStatus === 1) {\n      if (allowBlockCollections &&\n          (readBlockSequence(state, blockIndent) ||\n           readBlockMapping(state, blockIndent, flowIndent)) ||\n          readFlowCollection(state, flowIndent)) {\n        hasContent = true;\n      } else {\n        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||\n            readSingleQuotedScalar(state, flowIndent) ||\n            readDoubleQuotedScalar(state, flowIndent)) {\n          hasContent = true;\n\n        } else if (readAlias(state)) {\n          hasContent = true;\n\n          if (state.tag !== null || state.anchor !== null) {\n            throwError(state, 'alias node should not have any properties');\n          }\n\n        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n          hasContent = true;\n\n          if (state.tag === null) {\n            state.tag = '?';\n          }\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else if (indentStatus === 0) {\n      // Special case: block sequences are allowed to have same indentation level as the parent.\n      // http://www.yaml.org/spec/1.2/spec.html#id2799784\n      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n    }\n  }\n\n  if (state.tag === null) {\n    if (state.anchor !== null) {\n      state.anchorMap[state.anchor] = state.result;\n    }\n\n  } else if (state.tag === '?') {\n    // Implicit resolving is not allowed for non-scalar types, and '?'\n    // non-specific tag is only automatically assigned to plain scalars.\n    //\n    // We only need to check kind conformity in case user explicitly assigns '?'\n    // tag, for example like this: \"!<?> [0]\"\n    //\n    if (state.result !== null && state.kind !== 'scalar') {\n      throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n    }\n\n    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n      type = state.implicitTypes[typeIndex];\n\n      if (type.resolve(state.result)) { // `state.result` updated in resolver if matched\n        state.result = type.construct(state.result);\n        state.tag = type.tag;\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n        break;\n      }\n    }\n  } else if (state.tag !== '!') {\n    if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n      type = state.typeMap[state.kind || 'fallback'][state.tag];\n    } else {\n      // looking for multi type\n      type = null;\n      typeList = state.typeMap.multi[state.kind || 'fallback'];\n\n      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {\n        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {\n          type = typeList[typeIndex];\n          break;\n        }\n      }\n    }\n\n    if (!type) {\n      throwError(state, 'unknown tag !<' + state.tag + '>');\n    }\n\n    if (state.result !== null && type.kind !== state.kind) {\n      throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n    }\n\n    if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched\n      throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n    } else {\n      state.result = type.construct(state.result, state.tag);\n      if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = state.result;\n      }\n    }\n  }\n\n  if (state.listener !== null) {\n    state.listener('close', state);\n  }\n  return state.tag !== null ||  state.anchor !== null || hasContent;\n}\n\nfunction readDocument(state) {\n  var documentStart = state.position,\n      _position,\n      directiveName,\n      directiveArgs,\n      hasDirectives = false,\n      ch;\n\n  state.version = null;\n  state.checkLineBreaks = state.legacy;\n  state.tagMap = Object.create(null);\n  state.anchorMap = Object.create(null);\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (state.lineIndent > 0 || ch !== 0x25/* % */) {\n      break;\n    }\n\n    hasDirectives = true;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    directiveName = state.input.slice(_position, state.position);\n    directiveArgs = [];\n\n    if (directiveName.length < 1) {\n      throwError(state, 'directive name must not be less than one character in length');\n    }\n\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (ch === 0x23/* # */) {\n        do { ch = state.input.charCodeAt(++state.position); }\n        while (ch !== 0 && !is_EOL(ch));\n        break;\n      }\n\n      if (is_EOL(ch)) break;\n\n      _position = state.position;\n\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      directiveArgs.push(state.input.slice(_position, state.position));\n    }\n\n    if (ch !== 0) readLineBreak(state);\n\n    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {\n      directiveHandlers[directiveName](state, directiveName, directiveArgs);\n    } else {\n      throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n    }\n  }\n\n  skipSeparationSpace(state, true, -1);\n\n  if (state.lineIndent === 0 &&\n      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {\n    state.position += 3;\n    skipSeparationSpace(state, true, -1);\n\n  } else if (hasDirectives) {\n    throwError(state, 'directives end mark is expected');\n  }\n\n  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n  skipSeparationSpace(state, true, -1);\n\n  if (state.checkLineBreaks &&\n      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n    throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n  }\n\n  state.documents.push(state.result);\n\n  if (state.position === state.lineStart && testDocumentSeparator(state)) {\n\n    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n    }\n    return;\n  }\n\n  if (state.position < (state.length - 1)) {\n    throwError(state, 'end of the stream or a document separator is expected');\n  } else {\n    return;\n  }\n}\n\n\nfunction loadDocuments(input, options) {\n  input = String(input);\n  options = options || {};\n\n  if (input.length !== 0) {\n\n    // Add tailing `\\n` if not exists\n    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&\n        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {\n      input += '\\n';\n    }\n\n    // Strip BOM\n    if (input.charCodeAt(0) === 0xFEFF) {\n      input = input.slice(1);\n    }\n  }\n\n  var state = new State$1(input, options);\n\n  var nullpos = input.indexOf('\\0');\n\n  if (nullpos !== -1) {\n    state.position = nullpos;\n    throwError(state, 'null byte is not allowed in input');\n  }\n\n  // Use 0 as string terminator. That significantly simplifies bounds check.\n  state.input += '\\0';\n\n  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {\n    state.lineIndent += 1;\n    state.position += 1;\n  }\n\n  while (state.position < (state.length - 1)) {\n    readDocument(state);\n  }\n\n  return state.documents;\n}\n\n\nfunction loadAll$1(input, iterator, options) {\n  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  var documents = loadDocuments(input, options);\n\n  if (typeof iterator !== 'function') {\n    return documents;\n  }\n\n  for (var index = 0, length = documents.length; index < length; index += 1) {\n    iterator(documents[index]);\n  }\n}\n\n\nfunction load$1(input, options) {\n  var documents = loadDocuments(input, options);\n\n  if (documents.length === 0) {\n    /*eslint-disable no-undefined*/\n    return undefined;\n  } else if (documents.length === 1) {\n    return documents[0];\n  }\n  throw new exception('expected a single document in the stream, but found more');\n}\n\n\nvar loadAll_1 = loadAll$1;\nvar load_1    = load$1;\n\nvar loader = {\n\tloadAll: loadAll_1,\n\tload: load_1\n};\n\n/*eslint-disable no-use-before-define*/\n\n\n\n\n\nvar _toString       = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar CHAR_BOM                  = 0xFEFF;\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_EQUALS               = 0x3D; /* = */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nvar DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (map === null) return {};\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new exception('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\n\nvar QUOTING_TYPE_SINGLE = 1,\n    QUOTING_TYPE_DOUBLE = 2;\n\nfunction State(options) {\n  this.schema        = options['schema'] || _default;\n  this.indent        = Math.max(1, (options['indent'] || 2));\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid   = options['skipInvalid'] || false;\n  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys      = options['sortKeys'] || false;\n  this.lineWidth     = options['lineWidth'] || 80;\n  this.noRefs        = options['noRefs'] || false;\n  this.noCompatMode  = options['noCompatMode'] || false;\n  this.condenseFlow  = options['condenseFlow'] || false;\n  this.quotingType   = options['quotingType'] === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\n  this.forceQuotes   = options['forceQuotes'] || false;\n  this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n}\n\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isnâ€™t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n  return  (0x00020 <= c && c <= 0x00007E)\n      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)\n      ||  (0x10000 <= c && c <= 0x10FFFF);\n}\n\n// [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// Including s-white (for some reason, examples doesn't match specs in this aspect)\n// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\nfunction isNsCharOrWhitespace(c) {\n  return isPrintable(c)\n    && c !== CHAR_BOM\n    // - b-char\n    && c !== CHAR_CARRIAGE_RETURN\n    && c !== CHAR_LINE_FEED;\n}\n\n// [127]  ns-plain-safe(c) ::= c = flow-out  â‡’ ns-plain-safe-out\n//                             c = flow-in   â‡’ ns-plain-safe-in\n//                             c = block-key â‡’ ns-plain-safe-out\n//                             c = flow-key  â‡’ ns-plain-safe-in\n// [128] ns-plain-safe-out ::= ns-char\n// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\n// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - â€œ:â€ - â€œ#â€ )\n//                            | ( /* An ns-char preceding */ â€œ#â€ )\n//                            | ( â€œ:â€ /* Followed by an ns-plain-safe(c) */ )\nfunction isPlainSafe(c, prev, inblock) {\n  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\n  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\n  return (\n    // ns-plain-safe\n    inblock ? // c = flow-in\n      cIsNsCharOrWhitespace\n      : cIsNsCharOrWhitespace\n        // - c-flow-indicator\n        && c !== CHAR_COMMA\n        && c !== CHAR_LEFT_SQUARE_BRACKET\n        && c !== CHAR_RIGHT_SQUARE_BRACKET\n        && c !== CHAR_LEFT_CURLY_BRACKET\n        && c !== CHAR_RIGHT_CURLY_BRACKET\n  )\n    // ns-plain-char\n    && c !== CHAR_SHARP // false on '#'\n    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '\n    || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'\n    || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'\n}\n\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  // No support of ( ( â€œ?â€ | â€œ:â€ | â€œ-â€ ) /* Followed by an ns-plain-safe(c)) */ ) part\n  return isPrintable(c) && c !== CHAR_BOM\n    && !isWhitespace(c) // - s-white\n    // - (c-indicator ::=\n    // â€œ-â€ | â€œ?â€ | â€œ:â€ | â€œ,â€ | â€œ[â€ | â€œ]â€ | â€œ{â€ | â€œ}â€\n    && c !== CHAR_MINUS\n    && c !== CHAR_QUESTION\n    && c !== CHAR_COLON\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // | â€œ#â€ | â€œ&â€ | â€œ*â€ | â€œ!â€ | â€œ|â€ | â€œ=â€ | â€œ>â€ | â€œ'â€ | â€œ\"â€\n    && c !== CHAR_SHARP\n    && c !== CHAR_AMPERSAND\n    && c !== CHAR_ASTERISK\n    && c !== CHAR_EXCLAMATION\n    && c !== CHAR_VERTICAL_LINE\n    && c !== CHAR_EQUALS\n    && c !== CHAR_GREATER_THAN\n    && c !== CHAR_SINGLE_QUOTE\n    && c !== CHAR_DOUBLE_QUOTE\n    // | â€œ%â€ | â€œ@â€ | â€œ`â€)\n    && c !== CHAR_PERCENT\n    && c !== CHAR_COMMERCIAL_AT\n    && c !== CHAR_GRAVE_ACCENT;\n}\n\n// Simplified test for values allowed as the last character in plain style.\nfunction isPlainSafeLast(c) {\n  // just not whitespace or colon, it will be checked to be plain character later\n  return !isWhitespace(c) && c !== CHAR_COLON;\n}\n\n// Same as 'string'.codePointAt(pos), but works in older browsers.\nfunction codePointAt(string, pos) {\n  var first = string.charCodeAt(pos), second;\n  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\n    second = string.charCodeAt(pos + 1);\n    if (second >= 0xDC00 && second <= 0xDFFF) {\n      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n    }\n  }\n  return first;\n}\n\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN   = 1,\n    STYLE_SINGLE  = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED  = 4,\n    STYLE_DOUBLE  = 5;\n\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,\n  testAmbiguousType, quotingType, forceQuotes, inblock) {\n\n  var i;\n  var char = 0;\n  var prevChar = null;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n  var plain = isPlainSafeFirst(codePointAt(string, 0))\n          && isPlainSafeLast(codePointAt(string, string.length - 1));\n\n  if (singleLineOnly || forceQuotes) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true;\n        // Check if any line can be folded.\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine ||\n            // Foldable line = too long, and not more-indented.\n            (i - previousLineBreak - 1 > lineWidth &&\n             string[previousLineBreak + 1] !== ' ');\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n    // in case the end is missing a \\n\n    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n      (i - previousLineBreak - 1 > lineWidth &&\n       string[previousLineBreak + 1] !== ' '));\n  }\n  // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    if (plain && !forceQuotes && !testAmbiguousType(string)) {\n      return STYLE_PLAIN;\n    }\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n  }\n  // Edge case: block indentation indicator can only have one digit.\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  }\n  // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n  if (!forceQuotes) {\n    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n  }\n  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n}\n\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    â€¢ No ending newline => unaffected; already using strip \"-\" chomping.\n//    â€¢ Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey, inblock) {\n  state.dump = (function () {\n    if (string.length === 0) {\n      return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\n    }\n    if (!state.noCompatMode) {\n      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\n        return state.quotingType === QUOTING_TYPE_DOUBLE ? ('\"' + string + '\"') : (\"'\" + string + \"'\");\n      }\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth â‰¤ 40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n    var lineWidth = state.lineWidth === -1\n      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\n    var singleLineOnly = iskey\n      // No block styles in flow mode.\n      || (state.flowLevel > -1 && level >= state.flowLevel);\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,\n      testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {\n\n      case STYLE_PLAIN:\n        return string;\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(string, indent));\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string) + '\"';\n      default:\n        throw new exception('impossible error: invalid scalar style');\n    }\n  }());\n}\n\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n  // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n  var clip =          string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : (clip ? '' : '-');\n\n  return indentIndicator + chomp + '\\n';\n}\n\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n}\n\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlinesâ€”\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g;\n\n  // first line (possibly an empty line)\n  var result = (function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }());\n  // If we haven't reached the first content line yet, don't add an extra \\n.\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented;\n\n  // rest of the lines\n  var match;\n  while ((match = lineRe.exec(string))) {\n    var prefix = match[1], line = match[2];\n    moreIndented = (line[0] === ' ');\n    result += prefix\n      + (!prevMoreIndented && !moreIndented && line !== ''\n        ? '\\n' : '')\n      + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n}\n\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line;\n\n  // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n  var match;\n  // start is an inclusive index. end, curr, and next are exclusive.\n  var start = 0, end, curr = 0, next = 0;\n  var result = '';\n\n  // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n  while ((match = breakRe.exec(line))) {\n    next = match.index;\n    // maintain invariant: curr - start <= width\n    if (next - start > width) {\n      end = (curr > start) ? curr : next; // derive end <= length-2\n      result += '\\n' + line.slice(start, end);\n      // skip the space that was output as \\n\n      start = end + 1;                    // derive start <= length-1\n    }\n    curr = next;\n  }\n\n  // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n  result += '\\n';\n  // Insert a break if the remainder is too long and there is a break available.\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n}\n\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n  var result = '';\n  var char = 0;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n    char = codePointAt(string, i);\n    escapeSeq = ESCAPE_SEQUENCES[char];\n\n    if (!escapeSeq && isPrintable(char)) {\n      result += string[i];\n      if (char >= 0x10000) result += string[i + 1];\n    } else {\n      result += escapeSeq || encodeHex(char);\n    }\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level, value, false, false) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level, null, false, false))) {\n\n      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level + 1, value, true, true, false, true) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level + 1, null, true, true, false, true))) {\n\n      if (!compact || _result !== '') {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n    pairBuffer = '';\n    if (_result !== '') pairBuffer += ', ';\n\n    if (state.condenseFlow) pairBuffer += '\"';\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new exception('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || _result !== '') {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (state.tag !== null && state.tag !== '?') ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      if (explicit) {\n        if (type.multi && type.representName) {\n          state.tag = type.representName(object);\n        } else {\n          state.tag = type.tag;\n        }\n      } else {\n        state.tag = '?';\n      }\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new exception('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey, isblockseq) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n  var inblock = block;\n  var tagStr;\n\n  if (block) {\n    block = (state.flowLevel < 0 || state.flowLevel > level);\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if (type === '[object Object]') {\n      if (block && (Object.keys(state.dump).length !== 0)) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      if (block && (state.dump.length !== 0)) {\n        if (state.noArrayIndent && !isblockseq && level > 0) {\n          writeBlockSequence(state, level - 1, state.dump, compact);\n        } else {\n          writeBlockSequence(state, level, state.dump, compact);\n        }\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey, inblock);\n      }\n    } else if (type === '[object Undefined]') {\n      return false;\n    } else {\n      if (state.skipInvalid) return false;\n      throw new exception('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      // Need to encode all characters except those allowed by the spec:\n      //\n      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\n      // [36] ns-hex-digit    ::=  ns-dec-digit\n      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\n      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\n      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | â€œ-â€\n      // [39] ns-uri-char     ::=  â€œ%â€ ns-hex-digit ns-hex-digit | ns-word-char | â€œ#â€\n      //                         | â€œ;â€ | â€œ/â€ | â€œ?â€ | â€œ:â€ | â€œ@â€ | â€œ&â€ | â€œ=â€ | â€œ+â€ | â€œ$â€ | â€œ,â€\n      //                         | â€œ_â€ | â€œ.â€ | â€œ!â€ | â€œ~â€ | â€œ*â€ | â€œ'â€ | â€œ(â€ | â€œ)â€ | â€œ[â€ | â€œ]â€\n      //\n      // Also need to encode '!' because it has special meaning (end of tag prefix).\n      //\n      tagStr = encodeURI(\n        state.tag[0] === '!' ? state.tag.slice(1) : state.tag\n      ).replace(/!/g, '%21');\n\n      if (state.tag[0] === '!') {\n        tagStr = '!' + tagStr;\n      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {\n        tagStr = '!!' + tagStr.slice(18);\n      } else {\n        tagStr = '!<' + tagStr + '>';\n      }\n\n      state.dump = tagStr + ' ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList,\n      index,\n      length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump$1(input, options) {\n  options = options || {};\n\n  var state = new State(options);\n\n  if (!state.noRefs) getDuplicateReferences(input, state);\n\n  var value = input;\n\n  if (state.replacer) {\n    value = state.replacer.call({ '': value }, '', value);\n  }\n\n  if (writeNode(state, 0, value, true, true)) return state.dump + '\\n';\n\n  return '';\n}\n\nvar dump_1 = dump$1;\n\nvar dumper = {\n\tdump: dump_1\n};\n\nfunction renamed(from, to) {\n  return function () {\n    throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +\n      'Use yaml.' + to + ' instead, which is now safe by default.');\n  };\n}\n\n\nvar Type                = type;\nvar Schema              = schema;\nvar FAILSAFE_SCHEMA     = failsafe;\nvar JSON_SCHEMA         = json;\nvar CORE_SCHEMA         = core;\nvar DEFAULT_SCHEMA      = _default;\nvar load                = loader.load;\nvar loadAll             = loader.loadAll;\nvar dump                = dumper.dump;\nvar YAMLException       = exception;\n\n// Re-export all types in case user wants to create custom schema\nvar types = {\n  binary:    binary,\n  float:     float,\n  map:       map,\n  null:      _null,\n  pairs:     pairs,\n  set:       set,\n  timestamp: timestamp,\n  bool:      bool,\n  int:       int,\n  merge:     merge,\n  omap:      omap,\n  seq:       seq,\n  str:       str\n};\n\n// Removed functions from JS-YAML 3.0.x\nvar safeLoad            = renamed('safeLoad', 'load');\nvar safeLoadAll         = renamed('safeLoadAll', 'loadAll');\nvar safeDump            = renamed('safeDump', 'dump');\n\nvar jsYaml = {\n\tType: Type,\n\tSchema: Schema,\n\tFAILSAFE_SCHEMA: FAILSAFE_SCHEMA,\n\tJSON_SCHEMA: JSON_SCHEMA,\n\tCORE_SCHEMA: CORE_SCHEMA,\n\tDEFAULT_SCHEMA: DEFAULT_SCHEMA,\n\tload: load,\n\tloadAll: loadAll,\n\tdump: dump,\n\tYAMLException: YAMLException,\n\ttypes: types,\n\tsafeLoad: safeLoad,\n\tsafeLoadAll: safeLoadAll,\n\tsafeDump: safeDump\n};\n\nexport default jsYaml;\nexport { CORE_SCHEMA, DEFAULT_SCHEMA, FAILSAFE_SCHEMA, JSON_SCHEMA, Schema, Type, YAMLException, dump, load, loadAll, safeDump, safeLoad, safeLoadAll, types };\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/** Convert a directives first line and content to its structural components\n *\n * The code is adapted from: myst_parser/parse_directives.py\n * and is common for all directives\n */\n\nimport yaml from \"js-yaml\"\nimport type StateCore from \"markdown-it/lib/rules_core/state_core\"\nimport type Token from \"markdown-it/lib/token\"\nimport { OptionSpecConverter } from \"./options\"\nimport { nestedCoreParse } from \"../nestedCoreParse\"\n\n/** token specification for a directive */\nexport class DirectiveToken implements Token {\n  public type = \"directive\"\n  public tag = \"\"\n  public attrs = null\n  public nesting = 0 as 1 | 0 | -1\n  public level = 0\n  public children = null\n  public markup = \"\"\n  public block = true\n  public hidden = false\n  public info: string\n  public meta: { arg: string }\n  public content: string\n  public map: [number, number]\n  constructor(name: string, arg: string, content: string, map: [number, number]) {\n    this.info = name\n    this.meta = { arg }\n    this.content = content\n    this.map = map\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  attrIndex(name: string): number {\n    return -1\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  attrPush(attrData: [string, string]): void {\n    throw new Error(\"not implemented\")\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  attrSet(name: string, value: string): void {\n    throw new Error(\"not implemented\")\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  attrGet(name: string): null {\n    return null\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  attrJoin(name: string, value: string): void {\n    throw new Error(\"not implemented\")\n  }\n}\n\n/** Data required to parse a directive first line and content to its structure */\nexport interface IDirectiveSpec {\n  /** number of required arguments */\n  required_arguments?: number\n  /** number of optional arguments */\n  optional_arguments?: number\n  /** indicating if the final argument may contain whitespace */\n  final_argument_whitespace?: boolean\n  /** if body content is allowed */\n  has_content?: boolean\n  /** mapping known option names to conversion functions */\n  option_spec?: Record<string, OptionSpecConverter>\n  /** If true, do not attempt to validate/convert options. */\n  rawOptions?: boolean\n}\n\n/** A class to define a single directive */\nexport class Directive implements IDirectiveSpec {\n  public required_arguments = 0\n  public optional_arguments = 0\n  public final_argument_whitespace = false\n  public has_content = false\n  public option_spec = {}\n  public rawOptions = false\n  public state: StateCore\n  constructor(state: StateCore) {\n    this.state = state\n  }\n  /** Convert the directive data to tokens */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  run(data: IDirectiveData): Token[] {\n    return []\n  }\n  assert(test: boolean, msg: string): void {\n    if (!test) {\n      throw new Error(msg)\n    }\n  }\n  /** throw error is no body content parsed. */\n  assert_has_content(data: IDirectiveData): void {\n    if (!data.body) {\n      throw new Error(\"Content block expected, but none found.\")\n    }\n  }\n  /** Create a single token */\n  createToken(\n    type: string,\n    tag: string,\n    nesting: Token.Nesting,\n    optional?: {\n      content?: string\n      level?: number\n      map?: null | [number, number]\n      meta?: any\n      info?: string\n      block?: boolean\n      children?: Token[]\n    }\n  ): Token {\n    const token = new this.state.Token(type, tag, nesting)\n    if (optional?.content !== undefined) {\n      token.content = optional.content\n    }\n    if (optional?.level !== undefined) {\n      token.level = optional.level\n    }\n    if (optional?.map !== undefined) {\n      token.map = optional.map\n    }\n    if (optional?.block !== undefined) {\n      token.block = optional.block\n    }\n    if (optional?.info !== undefined) {\n      token.info = optional.info\n    }\n    if (optional?.meta !== undefined) {\n      token.meta = optional.meta\n    }\n    if (optional?.children !== undefined) {\n      token.children = optional.children\n    }\n    return token\n  }\n  /** parse block of text to tokens (does not run inline parse) */\n  nestedParse(block: string, initLine: number): Token[] {\n    return nestedCoreParse(\n      this.state.md,\n      \"run_directives\",\n      block,\n      this.state.env,\n      initLine,\n      true\n    )\n  }\n}\n\n/** Data structure of a directive */\nexport interface IDirectiveData<T extends string = string> {\n  map: [number, number]\n  args: string[]\n  options: Record<T, any>\n  body: string\n  bodyMap: [number, number]\n}\n\n/** Raise on parsing/validation error. */\nexport class DirectiveParsingError extends Error {\n  name = \"DirectiveParsingError\"\n}\n\n/**\n * This function contains the logic to take the first line of a directive,\n * and the content, and turn it into the three core components:\n * arguments (list), options (key: value mapping), and body (text).\n */\nexport default function directiveToData(\n  token: Token,\n  directive: IDirectiveSpec\n): IDirectiveData {\n  const firstLine = token.meta.arg || \"\"\n  const content = token.content\n  let body = content.trim() ? content.split(/\\r?\\n/) : []\n  let bodyOffset = 0\n  let options = {}\n  if (Object.keys(directive.option_spec || {}) || directive.rawOptions) {\n    ;[body, options, bodyOffset] = parseDirectiveOptions(body, directive)\n  }\n  let args: string[] = []\n  if (!directive.required_arguments && !directive.optional_arguments) {\n    if (firstLine) {\n      bodyOffset = 0\n      body = [firstLine].concat(body)\n    }\n  } else {\n    args = parseDirectiveArguments(firstLine, directive)\n  }\n  // remove first line of body if blank, to allow space between the options and the content\n  if (body.length && !body[0].trim()) {\n    body.shift()\n    bodyOffset++\n  }\n  // check for body content\n  if (body.length && !directive.has_content) {\n    throw new DirectiveParsingError(\"Has content but content not allowed\")\n  }\n  return {\n    map: token.map ? token.map : [0, 0],\n    args,\n    options,\n    body: body.join(\"\\n\"),\n    bodyMap: token.map\n      ? [\n          body.length > 0 ? token.map[0] + bodyOffset : token.map[1],\n          body.length > 0 ? token.map[1] - 1 : token.map[1]\n        ]\n      : [0, 0]\n  }\n}\n\nexport function parseDirectiveOptions(\n  content: string[],\n  fullSpec: IDirectiveSpec\n): [string[], { [key: string]: any }, number] {\n  // instantiate options\n  let bodyOffset = 1\n  let options: { [key: string]: any } = {}\n  let yamlBlock: null | string[] = null\n\n  // TODO allow for indented content (I can't remember why this was needed?)\n\n  if (content.length && content[0].startsWith(\"---\")) {\n    // options contained in YAML block, ending with '---'\n    bodyOffset++\n    const newContent: string[] = []\n    yamlBlock = []\n    let foundDivider = false\n    for (const line of content.slice(1)) {\n      if (line.startsWith(\"---\")) {\n        bodyOffset++\n        foundDivider = true\n        continue\n      }\n      if (foundDivider) {\n        newContent.push(line)\n      } else {\n        bodyOffset++\n        yamlBlock.push(line)\n      }\n    }\n    content = newContent\n  } else if (content.length && content[0].startsWith(\":\")) {\n    const newContent: string[] = []\n    yamlBlock = []\n    let foundDivider = false\n    for (const line of content) {\n      if (!foundDivider && !line.startsWith(\":\")) {\n        foundDivider = true\n        newContent.push(line)\n        continue\n      }\n      if (foundDivider) {\n        newContent.push(line)\n      } else {\n        bodyOffset++\n        yamlBlock.push(line.slice(1))\n      }\n    }\n    content = newContent\n  }\n\n  if (yamlBlock !== null) {\n    try {\n      const output = yaml.load(yamlBlock.join(\"\\n\"))\n      if (output !== null && typeof output === \"object\") {\n        options = output\n      } else {\n        throw new DirectiveParsingError(`not dict: ${output}`)\n      }\n    } catch (error) {\n      throw new DirectiveParsingError(`Invalid options YAML: ${error}`)\n    }\n  }\n\n  if (fullSpec.rawOptions) {\n    return [content, options, bodyOffset]\n  }\n\n  for (const [name, value] of Object.entries(options)) {\n    const convertor = fullSpec.option_spec ? fullSpec.option_spec[name] : null\n    if (!convertor) {\n      throw new DirectiveParsingError(`Unknown option: ${name}`)\n    }\n    let converted_value = value\n    if (value === null || value === false) {\n      converted_value = \"\"\n    }\n    try {\n      // In docutils all values are simply read as strings,\n      // but loading with YAML these can be converted to other types, so we convert them back first\n      // TODO check that it is sufficient to simply do this conversion, or if there is a better way\n      converted_value = convertor(`${converted_value || \"\"}`)\n    } catch (error) {\n      throw new DirectiveParsingError(\n        `Invalid option value: (option: '${name}'; value: ${value})\\n${error}`\n      )\n    }\n    options[name] = converted_value\n  }\n\n  return [content, options, bodyOffset]\n}\n\nfunction parseDirectiveArguments(\n  firstLine: string,\n  fullSpec: IDirectiveSpec\n): string[] {\n  let args = firstLine.trim() ? firstLine.trim()?.split(/\\s+/) : []\n  const totalArgs =\n    (fullSpec.required_arguments || 0) + (fullSpec.optional_arguments || 0)\n  if (args.length < (fullSpec.required_arguments || 0)) {\n    throw new DirectiveParsingError(\n      `${fullSpec.required_arguments} argument(s) required, ${args.length} supplied`\n    )\n  } else if (args.length > totalArgs) {\n    if (fullSpec.final_argument_whitespace) {\n      // note split limit does not work the same as in python\n      const arr = firstLine.split(/\\s+/)\n      args = arr.splice(0, totalArgs - 1)\n      // TODO is it ok that we effectively replace all whitespace with single spaces?\n      args.push(arr.join(\" \"))\n    } else {\n      throw new DirectiveParsingError(\n        `maximum ${totalArgs} argument(s) allowed, ${args.length} supplied`\n      )\n    }\n  }\n  return args\n}\n","import type MarkdownIt from \"markdown-it\"\nimport type Token from \"markdown-it/lib/token\"\n\n/** Perform a nested parse upto and including a particular ruleName\n *\n * The main use for this function is to perform nested parses\n * upto but not including inline parsing.\n */\nexport function nestedCoreParse(\n  md: MarkdownIt,\n  pluginRuleName: string,\n  src: string,\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any\n  env: any,\n  initLine: number,\n  includeRule = true\n): Token[] {\n  // disable all core rules after pluginRuleName\n  const tempDisabledCore: string[] = []\n  // TODO __rules__ is currently not exposed in typescript, but is the only way to get the rule names,\n  // since md.core.ruler.getRules('') only returns the rule functions\n  // we should upstream a getRuleNames() function or similar\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore TS2339\n  for (const rule of [...md.core.ruler.__rules__].reverse()) {\n    if (rule.name === pluginRuleName) {\n      if (!includeRule) {\n        tempDisabledCore.push(rule.name)\n      }\n      break\n    }\n    if (rule.name) {\n      tempDisabledCore.push(rule.name)\n    }\n  }\n\n  md.core.ruler.disable(tempDisabledCore)\n\n  let tokens = []\n  try {\n    tokens = md.parse(src, env)\n  } finally {\n    md.core.ruler.enable(tempDisabledCore)\n  }\n  for (const token of tokens) {\n    token.map =\n      token.map !== null\n        ? [token.map[0] + initLine, token.map[1] + initLine]\n        : token.map\n  }\n  return tokens\n}\n","import type MarkdownIt from \"markdown-it/lib\"\nimport type StateCore from \"markdown-it/lib/rules_core/state_core\"\nimport directiveToData, { Directive, parseDirectiveOptions } from \"./main\"\nimport { IOptions } from \"./types\"\n\nexport default function directivePlugin(md: MarkdownIt, options: IOptions): void {\n  let after = options.directivesAfter || \"block\"\n  if (options.replaceFences ?? true) {\n    md.core.ruler.after(after, \"fence_to_directive\", replaceFences)\n    after = \"fence_to_directive\"\n  }\n  md.core.ruler.after(after, \"run_directives\", runDirectives(options.directives || {}))\n\n  // fallback renderer for unhandled directives\n  md.renderer.rules[\"directive\"] = (tokens, idx) => {\n    const token = tokens[idx]\n    return `<aside class=\"directive-unhandled\">\\n<header><mark>${token.info}</mark><code> ${token.meta.arg}</code></header>\\n<pre>${token.content}</pre></aside>\\n`\n  }\n  md.renderer.rules[\"directive_error\"] = (tokens, idx) => {\n    const token = tokens[idx]\n    let content = \"\"\n    if (token.content) {\n      content = `\\n---\\n${token.content}`\n    }\n    return `<aside class=\"directive-error\">\\n<header><mark>${token.info}</mark><code> ${token.meta.arg}</code></header>\\n<pre>${token.meta.error_name}:\\n${token.meta.error_message}\\n${content}</pre></aside>\\n`\n  }\n}\n\n/** Convert fences identified as directives to `directive` tokens */\nfunction replaceFences(state: StateCore): boolean {\n  for (const token of state.tokens) {\n    if (token.type === \"fence\") {\n      const match = token.info.match(/^\\{([^\\s}]+)\\}\\s*(.*)$/)\n      if (match) {\n        if (match[1] == \"mermaid\" || match[1] == \"railroad\")\n          continue\n        token.type = \"directive\"\n        token.info = match[1]\n        token.meta = { arg: match[2] }\n      }\n    }\n  }\n  return true\n}\n\n/** Run all directives, replacing the original token */\nfunction runDirectives(directives: {\n  [key: string]: typeof Directive\n}): (state: StateCore) => boolean {\n  function func(state: StateCore): boolean {\n    const finalTokens = []\n    for (const token of state.tokens) {\n      // TODO directive name translations\n      if (token.type === \"directive\" && token.info in directives) {\n        try {\n          const directive = new directives[token.info](state)\n          const data = directiveToData(token, directive)\n          const [content, opts] = parseDirectiveOptions(\n            token.content.trim() ? token.content.split(/\\r?\\n/) : [],\n            directive\n          )\n          const directiveOpen = new state.Token(\"parsed_directive_open\", \"\", 1)\n          directiveOpen.info = token.info\n          directiveOpen.hidden = true\n          directiveOpen.content = content.join(\"\\n\").trim()\n          directiveOpen.meta = {\n            arg: token.meta.arg,\n            opts\n          }\n          const newTokens = [directiveOpen]\n          newTokens.push(...directive.run(data))\n          const directiveClose = new state.Token(\"parsed_directive_close\", \"\", -1)\n          directiveClose.hidden = true\n          newTokens.push(directiveClose)\n          // Ensure `meta` exists and add the directive options to parsed child\n          newTokens[1].meta = {\n            directive: true,\n            ...data.options,\n            ...newTokens[1].meta\n          }\n          finalTokens.push(...newTokens)\n        } catch (err) {\n          const errorToken = new state.Token(\"directive_error\", \"\", 0)\n          errorToken.content = token.content\n          errorToken.info = token.info\n          errorToken.meta = token.meta\n          errorToken.map = token.map\n          errorToken.meta.error_message = (err as Error).message\n          errorToken.meta.error_name = (err as Error).name\n          finalTokens.push(errorToken)\n        }\n      } else {\n        finalTokens.push(token)\n      }\n    }\n    state.tokens = finalTokens\n    return true\n  }\n  return func\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/** Functions for converting and validating directive options\n *\n * Primarily adapted from: docutils/docutils/parsers/rst/directives/__init__.py\n */\n\n/**\n * Normalize a string to HTML4 id\n *\n * Adapted from docutils/nodes.py::make_id,\n * it should be noted that in HTML5 the only requirement is no whitespace.\n * */\nexport function make_id(name: string): string {\n  // TODO make more complete\n  return name\n    .toLowerCase()\n    .split(/\\s+/)\n    .join(\"-\")\n    .replace(/[^a-z0-9]+/, \"-\")\n    .replace(/^[-0-9]+|-+$/, \"\")\n}\n\n/** convert and validate an option value */\nexport type OptionSpecConverter = (value: string, options?: any) => any\n\n/** Error to throw when an option is invalid. */\nexport class OptionSpecError extends Error {\n  name = \"OptionSpecError\"\n}\n\n/** Leave value unchanged */\nexport const unchanged: OptionSpecConverter = (value: string): string => value\n\n/** Leave value unchanged, but assert non-empty string */\nexport const unchanged_required: OptionSpecConverter = (value: string): string => {\n  if (!value) {\n    throw new OptionSpecError(\"Argument required but none supplied\")\n  }\n  return value\n}\n\n/** A flag option (no argument) */\nexport const flag: OptionSpecConverter = (value: string): null => {\n  if (value.trim()) {\n    throw new OptionSpecError(`No argument is allowed: \"${value}\" supplied`)\n  }\n  return null\n}\n\n/** Split values by whitespace and normalize to HTML4 id */\nexport const class_option: OptionSpecConverter = (value: string): string[] => {\n  return `${value || \"\"}`.split(/\\s+/).map(name => make_id(name))\n}\n\n/** Check for an integer argument and convert */\nexport function int(argument: string): number {\n  if (!argument) {\n    throw new OptionSpecError(\"Value is not set\")\n  }\n  const value = Number.parseFloat(argument)\n  if (Number.isNaN(value) || !Number.isInteger(value)) {\n    throw new OptionSpecError(`Value \"${argument}\" is not an integer`)\n  }\n  return value\n}\n\n/** Check for a non-negative integer argument and convert */\nexport function nonnegative_int(argument: string): number {\n  const value = int(argument)\n  if (value < 0) {\n    throw new OptionSpecError(`Value \"${argument}\" must be positive or zero`)\n  }\n  return value\n}\n\n/** A non-negative integer or null. */\nexport const optional_int: OptionSpecConverter = (value: string): null | number => {\n  if (!value) {\n    return null\n  }\n  return nonnegative_int(value)\n}\n\n/** Check for an integer percentage value with optional percent sign. */\nexport const percentage: OptionSpecConverter = (value: string): number => {\n  value = `${value || \"\"}`.replace(/\\s+%$/, \"\")\n  return nonnegative_int(value)\n}\n\n/** Check for a positive argument of one of the units and return a\n    normalized string of the form \"<value><unit>\" (without space in\n    between).\n*/\nfunction get_measure(argument: string, units: string[]): string {\n  const regex = new RegExp(`^(?<number>[0-9.]+)\\\\s*(?<units>${units.join(\"|\")})$`)\n  const match = regex.exec(argument)\n  if (!match || !match.groups) {\n    throw new OptionSpecError(\n      `not a positive measure of one of the following units: ${units.join(\"|\")}`\n    )\n  }\n  return match.groups.number + match.groups.units\n}\n\nconst length_units = [\"em\", \"ex\", \"px\", \"in\", \"cm\", \"mm\", \"pt\", \"pc\"]\n\n/** Check for a positive argument of a length unit, allowing for no unit. */\nexport const length_or_unitless: OptionSpecConverter = (value: string): string => {\n  return get_measure(value, [...length_units, \"\"])\n}\n\n/**\nReturn normalized string of a length or percentage unit.\n\nAdd <default> if there is no unit. Raise ValueError if the argument is not\na positive measure of one of the valid CSS units (or without unit).\n\n>>> length_or_percentage_or_unitless('3 pt')\n'3pt'\n>>> length_or_percentage_or_unitless('3%', 'em')\n'3%'\n>>> length_or_percentage_or_unitless('3')\n'3'\n>>> length_or_percentage_or_unitless('3', 'px')\n'3px'\n\n*/\nexport const length_or_percentage_or_unitless: OptionSpecConverter = (\n  argument: string,\n  defaultUnit = \"\"\n): string => {\n  try {\n    return get_measure(argument, [...length_units, \"%\"])\n  } catch {\n    return length_or_unitless(argument) + defaultUnit\n  }\n}\n\nexport const length_or_percentage_or_unitless_figure: OptionSpecConverter = (\n  argument: string,\n  defaultUnit = \"\"\n): string => {\n  if (argument.toLowerCase() === \"image\") {\n    return \"image\"\n  }\n  return length_or_percentage_or_unitless(argument, defaultUnit)\n}\n\n/** Create an option that asserts the (lower-cased & trimmed) value is a member of a choice set. */\nexport function create_choice(choices: string[]): OptionSpecConverter {\n  return (argument: string): string => {\n    argument = argument.toLowerCase().trim()\n    if (choices.includes(argument)) {\n      return argument\n    }\n    throw new OptionSpecError(`must be in: ${choices.join(\"|\")}`)\n  }\n}\n\n/** Return the URI argument with unescaped whitespace removed. */\nexport const uri: OptionSpecConverter = (value: string): string => {\n  // TODO implement whitespace removal\n  return value\n}\n","/** Directives for creating admonitions, also known as call-outs,\n * for including side content without significantly interrupting the document flow.\n */\nimport type Token from \"markdown-it/lib/token\"\nimport { class_option, unchanged } from \"./options\"\nimport { Directive, IDirectiveData } from \"./main\"\n\n/** Directives for admonition boxes.\n *\n * Apdapted from: docutils/docutils/parsers/rst/directives/admonitions.py\n */\nclass BaseAdmonition extends Directive {\n  public final_argument_whitespace = true\n  public has_content = true\n  public option_spec = {\n    class: class_option,\n    // TODO handle name option\n    name: unchanged\n  }\n  public title = \"\"\n  public kind = \"\"\n  run(data: IDirectiveData<keyof BaseAdmonition[\"option_spec\"]>): Token[] {\n    const newTokens: Token[] = []\n\n    // we create an overall container, then individual containers for the title and body\n    const adToken = this.createToken(\"admonition_open\", \"aside\", 1, {\n      map: data.map,\n      block: true,\n      meta: { kind: this.kind }\n    })\n    if (data.options.class?.length >= 1) {\n      // Custom class information must go first for styling\n      // For example, `class=tip, kind=seealso` should be styled as a `tip`\n      adToken.attrSet(\"class\", data.options.class.join(\" \"))\n      adToken.attrJoin(\"class\", \"admonition\")\n    } else {\n      adToken.attrSet(\"class\", \"admonition\")\n    }\n    if (this.kind) {\n      adToken.attrJoin(\"class\", this.kind)\n    }\n    newTokens.push(adToken)\n\n    const adTokenTitle = this.createToken(\"admonition_title_open\", \"header\", 1)\n    adTokenTitle.attrSet(\"class\", \"admonition-title\")\n    newTokens.push(adTokenTitle)\n\n    // we want the title to be parsed as Markdown during the inline phase\n    const title = data.args[0] || this.title\n    newTokens.push(\n      this.createToken(\"inline\", \"\", 0, {\n        map: [data.map[0], data.map[0]],\n        content: title,\n        children: []\n      })\n    )\n\n    newTokens.push(\n      this.createToken(\"admonition_title_close\", \"header\", -1, { block: true })\n    )\n\n    // run a recursive parse on the content of the admonition upto this stage\n    const bodyTokens = this.nestedParse(data.body, data.bodyMap[0])\n    newTokens.push(...bodyTokens)\n\n    newTokens.push(this.createToken(\"admonition_close\", \"aside\", -1, { block: true }))\n\n    return newTokens\n  }\n}\n\nexport class Admonition extends BaseAdmonition {\n  public required_arguments = 1\n}\n\nexport class Attention extends BaseAdmonition {\n  public title = \"Attention\"\n  public kind = \"attention\"\n}\n\nexport class Caution extends BaseAdmonition {\n  public title = \"Caution\"\n  public kind = \"caution\"\n}\n\nexport class Danger extends BaseAdmonition {\n  public title = \"Danger\"\n  public kind = \"danger\"\n}\n\nexport class Error extends BaseAdmonition {\n  public title = \"Error\"\n  public kind = \"error\"\n}\n\nexport class Important extends BaseAdmonition {\n  public title = \"Important\"\n  public kind = \"important\"\n}\n\nexport class Hint extends BaseAdmonition {\n  public title = \"Hint\"\n  public kind = \"hint\"\n}\n\nexport class Note extends BaseAdmonition {\n  public title = \"Note\"\n  public kind = \"note\"\n}\n\nexport class SeeAlso extends BaseAdmonition {\n  public title = \"See Also\"\n  public kind = \"seealso\"\n}\n\nexport class Tip extends BaseAdmonition {\n  public title = \"Tip\"\n  public kind = \"tip\"\n}\n\nexport class Warning extends BaseAdmonition {\n  public title = \"Warning\"\n  public kind = \"warning\"\n}\n\nexport const admonitions = {\n  admonition: Admonition,\n  attention: Attention,\n  caution: Caution,\n  danger: Danger,\n  error: Error,\n  important: Important,\n  hint: Hint,\n  note: Note,\n  seealso: SeeAlso,\n  tip: Tip,\n  warning: Warning\n}\n","/** Admonitions to visualise programming codes */\nimport type Token from \"markdown-it/lib/token\"\nimport { Directive, IDirectiveData } from \"./main\"\nimport {\n  class_option,\n  flag,\n  int,\n  optional_int,\n  unchanged,\n  unchanged_required\n} from \"./options\"\n\n// TODO add Highlight directive\n\n/** Mark up content of a code block\n *\n * Adapted from sphinx/directives/patches.py\n */\nexport class Code extends Directive {\n  public required_arguments = 0\n  public optional_arguments = 1\n  public final_argument_whitespace = false\n  public has_content = true\n  public option_spec = {\n    /** Add line numbers, optionally starting from a particular number. */\n    \"number-lines\": optional_int,\n    /** Ignore minor errors on highlighting */\n    force: flag,\n    name: unchanged,\n    class: class_option\n  }\n  run(data: IDirectiveData<keyof Code[\"option_spec\"]>): Token[] {\n    // TODO handle options\n    this.assert_has_content(data)\n    const token = this.createToken(\"fence\", \"code\", 0, {\n      // TODO if not specified, the language should come from a central configuration \"highlight_language\"\n      info: data.args ? data.args[0] : \"\",\n      content: data.body,\n      map: data.bodyMap\n    })\n    return [token]\n  }\n}\n\n/** Mark up content of a code block, with more settings\n *\n * Adapted from sphinx/directives/code.py\n */\nexport class CodeBlock extends Directive {\n  public required_arguments = 0\n  public optional_arguments = 1\n  public final_argument_whitespace = false\n  public has_content = true\n  public option_spec = {\n    /** Add line numbers. */\n    linenos: flag,\n    /** Start line numbering from a particular value. */\n    \"lineno-start\": int,\n    /** Strip indentation characters from the code block.\n     * When number given, leading N characters are removed\n     */\n    dedent: optional_int,\n    /** Emphasize particular lines (comma-separated numbers) */\n    \"emphasize-lines\": unchanged_required,\n    caption: unchanged_required,\n    /** Ignore minor errors on highlighting */\n    force: flag,\n    name: unchanged,\n    class: class_option\n  }\n  run(data: IDirectiveData<keyof CodeBlock[\"option_spec\"]>): Token[] {\n    // TODO handle options\n    this.assert_has_content(data)\n    const token = this.createToken(\"fence\", \"code\", 0, {\n      // TODO if not specified, the language should come from a central configuration \"highlight_language\"\n      info: data.args ? data.args[0] : \"\",\n      content: data.body,\n      map: data.bodyMap\n    })\n    return [token]\n  }\n}\n\n/** A code cell is a special MyST based cell, signifying executable code. */\nexport class CodeCell extends Directive {\n  public required_arguments = 0\n  public optional_arguments = 1\n  public final_argument_whitespace = false\n  public has_content = true\n  public rawOptions = true\n\n  run(data: IDirectiveData<keyof CodeCell[\"option_spec\"]>): Token[] {\n    // TODO store options and the fact that this is a code cell rather than a fence?\n    const token = this.createToken(\"fence\", \"code\", 0, {\n      info: data.args ? data.args[0] : \"\",\n      content: data.body,\n      map: data.bodyMap\n    })\n    return [token]\n  }\n}\n\nexport const code = {\n  code: Code,\n  \"code-block\": CodeBlock,\n  \"code-cell\": CodeCell\n}\n","/** Directives for image visualisation */\nimport type Token from \"markdown-it/lib/token\"\nimport { newTarget, Target, TargetKind } from \"../state/utils\"\nimport { Directive, IDirectiveData } from \"./main\"\nimport {\n  class_option,\n  create_choice,\n  length_or_percentage_or_unitless,\n  length_or_percentage_or_unitless_figure,\n  length_or_unitless,\n  percentage,\n  unchanged,\n  unchanged_required,\n  uri\n} from \"./options\"\n\nconst shared_option_spec = {\n  alt: unchanged,\n  height: length_or_unitless,\n  width: length_or_percentage_or_unitless,\n  // TODO handle scale option\n  scale: percentage,\n  // TODO handle target option\n  target: unchanged_required,\n  class: class_option,\n  // TODO handle name option (note: should be applied to figure for Figure)\n  name: unchanged\n}\n\n/** Directive for a single image.\n *\n * Adapted from: docutils/docutils/parsers/rst/directives/images.py\n */\nexport class Image extends Directive {\n  public required_arguments = 1\n  public optional_arguments = 0\n  public final_argument_whitespace = true\n  public option_spec = {\n    ...shared_option_spec,\n    align: create_choice([\"left\", \"center\", \"right\", \"top\", \"middle\", \"bottom\"])\n  }\n  create_image(data: IDirectiveData<keyof Image[\"option_spec\"]>): Token {\n    // get URI\n    const src = uri(data.args[0] || \"\")\n\n    const token = this.createToken(\"image\", \"img\", 0, { map: data.map, block: true })\n    token.attrSet(\"src\", src)\n    token.attrSet(\"alt\", data.options.alt || \"\")\n    // TODO markdown-it default renderer requires the alt as children tokens\n    const altTokens: Token[] = []\n    if (data.options.alt) {\n      this.state.md.inline.parse(\n        data.options.alt,\n        this.state.md,\n        this.state.env,\n        altTokens\n      )\n    }\n    token.children = altTokens\n    if (data.options.height) {\n      token.attrSet(\"height\", data.options.height)\n    }\n    if (data.options.width) {\n      token.attrSet(\"width\", data.options.width)\n    }\n    if (data.options.align) {\n      token.attrJoin(\"class\", `align-${data.options.align}`)\n    }\n    if (data.options.class) {\n      token.attrJoin(\"class\", data.options.class.join(\" \"))\n    }\n\n    return token\n  }\n  run(data: IDirectiveData): Token[] {\n    return [this.create_image(data)]\n  }\n}\n\n/** Directive for an image with caption.\n *\n * Adapted from: docutils/docutils/parsers/rst/directives/images.py,\n * and sphinx/directives/patches.py (patch to apply name to figure instead of image)\n */\nexport class Figure extends Image {\n  public option_spec = {\n    ...shared_option_spec,\n    align: create_choice([\"left\", \"center\", \"right\"]),\n    figwidth: length_or_percentage_or_unitless_figure,\n    figclass: class_option\n  }\n  public has_content = true\n  run(data: IDirectiveData<keyof Figure[\"option_spec\"]>): Token[] {\n    const openToken = this.createToken(\"figure_open\", \"figure\", 1, {\n      map: data.map,\n      block: true\n    })\n    if (data.options.figclass) {\n      openToken.attrJoin(\"class\", data.options.figclass.join(\" \"))\n    }\n    if (data.options.align) {\n      openToken.attrJoin(\"class\", `align-${data.options.align}`)\n    }\n    if (data.options.figwidth && data.options.figwidth !== \"image\") {\n      // TODO handle figwidth == \"image\"?\n      openToken.attrSet(\"width\", data.options.figwidth)\n    }\n    let target: Target | undefined\n    if (data.options.name) {\n      // TODO: figure out how to pass silent here\n      target = newTarget(\n        this.state,\n        openToken,\n        TargetKind.figure,\n        data.options.name,\n        // TODO: a better title?\n        data.body.trim()\n      )\n      openToken.attrJoin(\"class\", \"numbered\")\n    }\n    const imageToken = this.create_image(data)\n    imageToken.map = [data.map[0], data.map[0]]\n    let captionTokens: Token[] = []\n    let legendTokens: Token[] = []\n    if (data.body) {\n      const [caption, ...legendParts] = data.body.split(\"\\n\\n\")\n      const legend = legendParts.join(\"\\n\\n\")\n      const captionMap = data.bodyMap[0]\n      const openCaption = this.createToken(\"figure_caption_open\", \"figcaption\", 1, {\n        block: true\n      })\n      if (target) {\n        openCaption.attrSet(\"number\", `${target.number}`)\n      }\n      // TODO in docutils caption can only be single paragraph (or ignored if comment)\n      // then additional content is figure legend\n      const captionBody = this.nestedParse(caption, captionMap)\n      const closeCaption = this.createToken(\"figure_caption_close\", \"figcaption\", -1, {\n        block: true\n      })\n      captionTokens = [openCaption, ...captionBody, closeCaption]\n      if (legend) {\n        const legendMap = captionMap + caption.split(\"\\n\").length + 1\n        const openLegend = this.createToken(\"figure_legend_open\", \"\", 1, {\n          block: true\n        })\n        const legendBody = this.nestedParse(legend, legendMap)\n        const closeLegend = this.createToken(\"figure_legend_close\", \"\", -1, {\n          block: true\n        })\n        legendTokens = [openLegend, ...legendBody, closeLegend]\n      }\n    }\n    const closeToken = this.createToken(\"figure_close\", \"figure\", -1, { block: true })\n    return [openToken, imageToken, ...captionTokens, ...legendTokens, closeToken]\n  }\n}\n\nexport const images = {\n  image: Image,\n  figure: Figure\n}\n","/** A tree representation of a linear markdown-it token stream.\n *\n * Ported from: markdown-it-py/markdown_it/tree.py\n */\nimport Token from \"markdown-it/lib/token\"\n\ninterface NesterTokens {\n  opening: Token\n  closing: Token\n}\n\n/**A Markdown syntax tree node.\n\nA class that can be used to construct a tree representation of a linear\n`markdown-it` token stream.\n\nEach node in the tree represents either:\n    - root of the Markdown document\n    - a single unnested `Token`\n    - a `Token` \"_open\" and \"_close\" token pair, and the tokens nested in\n        between\n*/\nexport class SyntaxTreeNode {\n  private token?: Token\n  private nester_tokens?: NesterTokens\n  public parent?: SyntaxTreeNode\n  public children: SyntaxTreeNode[] = []\n  /** Initialize a `SyntaxTreeNode` from a token stream. */\n  constructor(tokens: Token[], create_root = true) {\n    this.children = []\n    if (create_root) {\n      this._set_children_from_tokens(tokens)\n      return\n    }\n    if (tokens.length === 0) {\n      throw new Error(\"Tree creation: Can only create root from empty token sequence.\")\n    }\n    if (tokens.length === 1) {\n      const inline_token = tokens[0]\n      if (inline_token.nesting) {\n        throw new Error(\"Unequal nesting level at the start and end of token stream.\")\n      }\n      this.token = inline_token\n      if (inline_token.children !== null && inline_token.children.length > 0) {\n        this._set_children_from_tokens(inline_token.children)\n      }\n    } else {\n      this.nester_tokens = { opening: tokens[0], closing: tokens[tokens.length - 1] }\n      this._set_children_from_tokens(tokens.slice(1, -1))\n    }\n  }\n  private _set_children_from_tokens(tokens: Token[]): void {\n    const revered_tokens = [...tokens].reverse()\n    let token: Token | undefined\n    while (revered_tokens.length > 0) {\n      token = revered_tokens.pop()\n      if (!token) {\n        break\n      }\n      if (!token.nesting) {\n        this._add_child([token])\n        continue\n      }\n      if (token.nesting !== 1) {\n        throw new Error(\"Invalid token nesting\")\n      }\n      const nested_tokens = [token]\n      let nesting = 1\n      while (revered_tokens.length > 0 && nesting !== 0) {\n        token = revered_tokens.pop()\n        if (token) {\n          nested_tokens.push(token)\n          nesting += token.nesting\n        }\n      }\n      if (nesting) {\n        throw new Error(`unclosed tokens starting: ${nested_tokens[0]}`)\n      }\n      this._add_child(nested_tokens)\n    }\n  }\n  private _add_child(tokens: Token[]): void {\n    const child = new SyntaxTreeNode(tokens, false)\n    child.parent = this\n    this.children.push(child)\n  }\n  /** Recover the linear token stream. */\n  to_tokens(): Token[] {\n    function recursive_collect_tokens(node: SyntaxTreeNode, token_list: Token[]): void {\n      if (node.type === \"root\") {\n        for (const child of node.children) {\n          recursive_collect_tokens(child, token_list)\n        }\n      } else if (node.token) {\n        token_list.push(node.token)\n      } else {\n        if (!node.nester_tokens) {\n          throw new Error(\"No nested token available\")\n        }\n        token_list.push(node.nester_tokens.opening)\n        for (const child of node.children) {\n          recursive_collect_tokens(child, token_list)\n        }\n        token_list.push(node.nester_tokens.closing)\n      }\n    }\n    const tokens: Token[] = []\n    recursive_collect_tokens(this, tokens)\n    return tokens\n  }\n  /** Is the node a special root node? */\n  get is_root(): boolean {\n    return !(this.token || this.nester_tokens)\n  }\n  /** Is this node nested? */\n  get is_nested(): boolean {\n    return !!this.nester_tokens\n  }\n  /** Get siblings of the node (including self). */\n  get siblings(): SyntaxTreeNode[] {\n    if (!this.parent) {\n      return [this]\n    }\n    return this.parent.children\n  }\n  /** Recursively yield all descendant nodes in the tree starting at self.\n   *\n   * The order mimics the order of the underlying linear token stream (i.e. depth first).\n   */\n  *walk(include_self = true): Generator<SyntaxTreeNode> {\n    if (include_self) {\n      yield this\n    }\n    for (const child of this.children) {\n      yield* child.walk(true)\n    }\n  }\n  /** Get a string type of the represented syntax.\n   * \n    - \"root\" for root nodes\n    - `Token.type` if the node represents an un-nested token\n    - `Token.type` of the opening token, with \"_open\" suffix stripped, if\n        the node represents a nester token pair\n  */\n  get type(): string {\n    if (this.is_root) {\n      return \"root\"\n    }\n    if (this.token) {\n      return this.token.type\n    }\n    if (this.nester_tokens?.opening.type.endsWith(\"_open\")) {\n      return this.nester_tokens?.opening.type.slice(0, -5)\n    }\n    if (this.nester_tokens) {\n      return this.nester_tokens?.opening.type\n    }\n    throw new Error(\"no internal token\")\n  }\n  private attribute_token(): Token {\n    if (this.token) {\n      return this.token\n    }\n    if (this.nester_tokens) {\n      return this.nester_tokens.opening\n    }\n    throw new Error(\"Tree node does not have the accessed attribute\")\n  }\n  get tag(): string {\n    return this.attribute_token().tag\n  }\n  get level(): number {\n    return this.attribute_token().level\n  }\n  get content(): string {\n    return this.attribute_token().content\n  }\n  get markup(): string {\n    return this.attribute_token().markup\n  }\n  get info(): string {\n    return this.attribute_token().info\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  get meta(): any {\n    return this.attribute_token().meta\n  }\n  get block(): boolean {\n    return this.attribute_token().block\n  }\n  get hidden(): boolean {\n    return this.attribute_token().hidden\n  }\n  get map(): [number, number] | null {\n    return this.attribute_token().map\n  }\n  get attrs(): [string, string][] | null {\n    return this.attribute_token().attrs\n  }\n}\n","/** Directives for creating tables */\nimport type Token from \"markdown-it/lib/token\"\nimport { SyntaxTreeNode } from \"../syntaxTree\"\nimport { Directive, DirectiveParsingError, IDirectiveData } from \"./main\"\nimport {\n  class_option,\n  create_choice,\n  length_or_percentage_or_unitless,\n  nonnegative_int,\n  unchanged\n} from \"./options\"\n\nexport class ListTable extends Directive {\n  public required_arguments = 0\n  public optional_arguments = 1\n  public final_argument_whitespace = true\n  public has_content = true\n  public option_spec = {\n    \"header-rows\": nonnegative_int,\n    \"stub-columns\": nonnegative_int,\n    width: length_or_percentage_or_unitless,\n    widths: unchanged, // TODO use correct widths option validator\n    class: class_option,\n    name: unchanged,\n    align: create_choice([\"left\", \"center\", \"right\"])\n  }\n  run(data: IDirectiveData): Token[] {\n    // TODO support all options (add colgroup for widths)\n    // Parse content\n    this.assert_has_content(data)\n    const headerRows = (data.options[\"header-rows\"] || 0) as number\n    const listTokens = this.nestedParse(data.body, data.bodyMap[0])\n    // Check content is a list\n    if (\n      listTokens.length < 2 ||\n      listTokens[0].type !== \"bullet_list_open\" ||\n      listTokens[listTokens.length - 1].type !== \"bullet_list_close\"\n    ) {\n      throw new DirectiveParsingError(\"Content is not a single bullet list\")\n    }\n\n    // generate tokens\n    const tokens: Token[] = []\n\n    // table opening\n    const tableOpen = this.createToken(\"table_open\", \"table\", 1, { map: data.bodyMap })\n    if (data.options.align) {\n      tableOpen.attrJoin(\"class\", `align-${data.options.align}`)\n    }\n    if (data.options.class) {\n      tableOpen.attrJoin(\"class\", data.options.class.join(\" \"))\n    }\n    tokens.push(tableOpen)\n\n    // add caption\n    if (data.args.length && data.args[0]) {\n      tokens.push(this.createToken(\"table_caption_open\", \"caption\", 1))\n      tokens.push(\n        this.createToken(\"inline\", \"\", 0, {\n          map: [data.map[0], data.map[0]],\n          content: data.args[0],\n          children: []\n        })\n      )\n      tokens.push(this.createToken(\"table_caption_close\", \"caption\", -1))\n    }\n\n    let colType: \"th\" | \"td\" = \"th\"\n    if (headerRows) {\n      tokens.push(this.createToken(\"thead_open\", \"thead\", 1, { level: 1 }))\n      colType = \"th\"\n    } else {\n      tokens.push(this.createToken(\"tbody_open\", \"tbody\", 1, { level: 1 }))\n      colType = \"td\"\n    }\n\n    let rowLength: number | undefined = undefined\n    let rowNumber = 0\n    for (const child of new SyntaxTreeNode(listTokens.slice(1, -1)).children) {\n      rowNumber += 1\n      this.assert(\n        child.type === \"list_item\",\n        `list item ${rowNumber} not of type 'list_item': ${child.type}`\n      )\n      this.assert(\n        child.children.length === 1 && child.children[0].type === \"bullet_list\",\n        `list item ${rowNumber} content not a nested bullet list`\n      )\n      const row = child.children[0].children\n      if (rowLength === undefined) {\n        rowLength = row.length\n      } else {\n        this.assert(\n          row.length === rowLength,\n          `list item ${rowNumber} does not contain the same number of columns as previous items`\n        )\n      }\n      if (headerRows && rowNumber === headerRows + 1) {\n        tokens.push(this.createToken(\"thead_close\", \"thead\", -1, { level: 1 }))\n        tokens.push(this.createToken(\"tbody_open\", \"tbody\", 1, { level: 1 }))\n        colType = \"td\"\n      }\n      tokens.push(this.createToken(\"tr_open\", \"tr\", 1, { map: child.map, level: 2 }))\n      for (const column of row) {\n        tokens.push(\n          this.createToken(`${colType}_open`, colType, 1, { map: column.map, level: 3 })\n        )\n        // TODO if the list is not tight then all paragraphs will be un-hidden maybe we don't want this?\n        tokens.push(...column.to_tokens().slice(1, -1))\n        tokens.push(this.createToken(`${colType}_close`, colType, -1, { level: 3 }))\n      }\n      tokens.push(this.createToken(\"tr_close\", \"tr\", -1, { level: 2 }))\n    }\n\n    if (headerRows && rowNumber < headerRows) {\n      throw new Error(\n        `Insufficient rows (${rowNumber}) for required header rows (${headerRows})`\n      )\n    }\n\n    // closing tokens\n    if (colType === \"td\") {\n      tokens.push(this.createToken(\"tbody_close\", \"tbody\", -1, { level: 1 }))\n    } else {\n      tokens.push(this.createToken(\"thead_close\", \"thead\", -1, { level: 1 }))\n    }\n    tokens.push(this.createToken(\"table_close\", \"table\", -1))\n\n    return tokens\n  }\n}\n\nexport const tables = {\n  \"list-table\": ListTable\n}\n","/** Admonitions to visualise programming codes */\nimport type Token from \"markdown-it/lib/token\"\nimport { newTarget, Target, TargetKind } from \"../state/utils\"\nimport { Directive, IDirectiveData } from \"./main\"\nimport { unchanged } from \"./options\"\n\n/** Math directive with a label\n */\nexport class Math extends Directive {\n  public required_arguments = 0\n  public optional_arguments = 0\n  public final_argument_whitespace = false\n  public has_content = true\n  public option_spec = {\n    label: unchanged\n  }\n  run(data: IDirectiveData<keyof Math[\"option_spec\"]>): Token[] {\n    // TODO handle options\n    this.assert_has_content(data)\n    const token = this.createToken(\"math_block\", \"div\", 0, {\n      content: data.body,\n      map: data.bodyMap,\n      block: true\n    })\n    token.attrSet(\"class\", \"math block\")\n    if (data.options.label) {\n      token.attrSet(\"id\", data.options.label)\n      const target: Target = newTarget(\n        this.state,\n        token,\n        TargetKind.equation,\n        data.options.label,\n        \"\"\n      )\n      token.attrSet(\"number\", `${target.number}`)\n      token.info = data.options.label\n      token.meta = { label: data.options.label, numbered: true, number: target.number }\n    }\n    return [token]\n  }\n}\n\nexport const math = {\n  math: Math\n}\n","export { Directive, IDirectiveData } from \"./main\"\nexport { default as directivePlugin } from \"./plugin\"\nexport * as directiveOptions from \"./options\"\nexport type { IOptions as IDirectiveOptions } from \"./types\"\n\nexport { admonitions } from \"./admonitions\"\nexport { code } from \"./code\"\nexport { images } from \"./images\"\nexport { tables } from \"./tables\"\nexport { math } from \"./math\"\n\nimport { admonitions } from \"./admonitions\"\nimport { code } from \"./code\"\nimport { images } from \"./images\"\nimport { tables } from \"./tables\"\nimport { math } from \"./math\"\n\nexport const directivesDefault = {\n  ...admonitions,\n  ...images,\n  ...code,\n  ...tables,\n  ...math\n}\n","import type MarkdownIt from \"markdown-it\"\nimport { RuleCore } from \"markdown-it/lib/parser_core\"\nimport type StateCore from \"markdown-it/lib/rules_core/state_core\"\nimport { getDocState, Target } from \"./utils\"\n\n/** Allowed options for state plugin */\nexport type IOptions = Record<string, never> // TODO: Figure out state numbering options\n\nfunction numberingRule(options: IOptions): RuleCore {\n  return (state: StateCore) => {\n    const env = getDocState(state)\n\n    env.references.forEach(ref => {\n      const { label, tokens, contentFromTarget } = ref\n\n      const setError = (details: string, error?: Target) => {\n        tokens.open.attrJoin(\"class\", \"error\")\n        tokens.open.tag = tokens.close.tag = \"code\"\n        if (contentFromTarget && error) {\n          tokens.content.content = contentFromTarget(error)\n        } else {\n          tokens.content.content = details\n        }\n        return true\n      }\n\n      const target = env.targets[label]\n      if (!target)\n        return setError(label, {\n          kind: ref.kind || \"\",\n          label,\n          title: label,\n          number: `\"${label}\"`\n        })\n      if (ref.kind && target.kind !== ref.kind) {\n        return setError(`Reference \"${label}\" does not match kind \"${ref.kind}\"`)\n      }\n      tokens.open.attrSet(\"href\", `#${target.label}`)\n      if (target.title) tokens.open.attrSet(\"title\", target.title)\n      if (contentFromTarget) tokens.content.content = contentFromTarget(target).trim()\n    })\n\n    // TODO: Math that wasn't pre-numbered?\n    return true\n  }\n}\n\n/**\n * Create a rule that runs at the end of a markdown-it parser to go through all\n * references and add their targets.\n *\n * This `Rule` is done *last*, as you may reference a figure/equation, when that `Target`\n * has not yet been created. The references call `resolveRefLater` when they are being\n * created and pass their tokens such that the content of those tokens can be\n * dynamically updated.\n *\n * @param options (none currently)\n * @returns The markdown-it Rule\n */\nexport default function statePlugin(md: MarkdownIt, options: IOptions): void {\n  md.core.ruler.push(\"docutils_number\", numberingRule(options))\n}\n","import type MarkdownIt from \"markdown-it/lib\"\nimport { rolesDefault, Role, rolePlugin, IRoleOptions, IRoleData } from \"./roles\"\nimport {\n  directivesDefault,\n  Directive,\n  directivePlugin,\n  directiveOptions,\n  IDirectiveOptions,\n  IDirectiveData\n} from \"./directives\"\nimport statePlugin from \"./state/plugin\"\n\nexport { rolesDefault, rolePlugin, Role }\nexport { directivesDefault, directivePlugin, Directive, directiveOptions }\n\nexport type { IRoleData, IRoleOptions, IDirectiveData, IDirectiveOptions }\n\n/** Allowed options for docutils plugin */\nexport interface IOptions extends IDirectiveOptions, IRoleOptions {\n  // TODO new token render rules\n}\n\n/** Default options for docutils plugin */\nconst OptionDefaults: IOptions = {\n  parseRoles: true,\n  replaceFences: true,\n  rolesAfter: \"inline\",\n  directivesAfter: \"block\",\n  directives: directivesDefault,\n  roles: rolesDefault\n}\n\n/**\n * A markdown-it plugin for implementing docutils style roles and directives.\n */\nexport function docutilsPlugin(md: MarkdownIt, options?: IOptions): void {\n  const fullOptions = { ...OptionDefaults, ...options }\n\n  md.use(rolePlugin, fullOptions)\n  md.use(directivePlugin, fullOptions)\n  md.use(statePlugin, fullOptions)\n}\n\n// Note: Exporting default and the function as a named export.\n//       This helps with Jest integration in downstream packages.\nexport default docutilsPlugin\n"],"names":["Role","constructor","state","this","run","data","main","raw","token","Token","content","math","inline","attrSet","markup","rolePlugin","md","options","parseRoles","ruler","before","roleRule","core","after","rolesAfter","roles","func","tokens","type","children","childTokens","child","meta","name","role","roleOpen","hidden","block","newTokens","push","parentMap","map","roleClose","err","errorToken","info","error_message","message","error_name","runRoles","renderer","rules","idx","opts","c","utils","escapeHtml","trim","displayMode","attrGet","inlineMathRenderer","silent","src","charCodeAt","pos","match","ROLE_PATTERN","exec","slice","str","length","_x","RegExp","error","Subscript","open","text","close","Superscript","ABBR_PATTERN","Abbreviation","title","html","subscript","sub","superscript","sup","abbreviation","abbr","TargetKind","getDocState","env","docutils","targets","references","numbering","newTarget","kind","label","number","nextNumber","target","getNamespacedMeta","resolveRefLater","value","REF_PATTERN","eq","equation","contentFromTarget","ref","modified","withoutLabel","numref","replace","String","rolesDefault","isNothing","subject","common","isObject","toArray","sequence","Array","isArray","repeat","string","count","cycle","result","isNegativeZero","Number","NEGATIVE_INFINITY","extend","source","index","key","sourceKeys","Object","keys","formatError","exception","compact","where","reason","mark","line","column","snippet","YAMLException$1","Error","call","captureStackTrace","stack","prototype","create","toString","getLine","buffer","lineStart","lineEnd","position","maxLineLength","head","tail","maxHalfLength","Math","floor","padStart","max","maxLength","indent","linesBefore","linesAfter","re","lineStarts","lineEnds","foundLineNo","i","lineNoLength","min","TYPE_CONSTRUCTOR_OPTIONS","YAML_NODE_KINDS","tag","forEach","indexOf","resolve","construct","instanceOf","predicate","represent","representName","defaultStyle","multi","styleAliases","style","alias","compileStyleAliases","compileList","schema","currentType","newIndex","previousType","previousIndex","Schema$1","definition","implicit","explicit","concat","type$1","loadKind","compiledImplicit","compiledExplicit","compiledTypeMap","scalar","mapping","fallback","collectType","arguments","compileMap","seq","failsafe","_null","object","canonical","lowercase","uppercase","camelcase","empty","bool","isOctCode","isDecCode","int","ch","hasDigits","sign","parseInt","binary","obj","octal","decimal","hexadecimal","toUpperCase","YAML_FLOAT_PATTERN","SCIENTIFIC_WITHOUT_DOT","float","test","toLowerCase","POSITIVE_INFINITY","NaN","parseFloat","res","isNaN","json","YAML_DATE_REGEXP","YAML_TIMESTAMP_REGEXP","timestamp","year","month","day","hour","minute","second","date","fraction","delta","Date","UTC","setTime","getTime","toISOString","merge","BASE64_MAP","code","bitlen","charAt","tailbits","input","bits","Uint8Array","_hasOwnProperty$3","hasOwnProperty","_toString$2","omap","pair","pairKey","pairHasKey","objectKeys","_toString$1","pairs","_hasOwnProperty$2","set","_default","_hasOwnProperty$1","PATTERN_NON_PRINTABLE","PATTERN_NON_ASCII_LINE_BREAKS","PATTERN_FLOW_INDICATORS","PATTERN_TAG_HANDLE","PATTERN_TAG_URI","_class","is_EOL","is_WHITE_SPACE","is_WS_OR_EOL","is_FLOW_INDICATOR","fromHexCode","lc","simpleEscapeSequence","charFromCodepoint","fromCharCode","simpleEscapeCheck","simpleEscapeMap","State$1","filename","onWarning","legacy","listener","implicitTypes","typeMap","lineIndent","firstTabInLine","documents","generateError","throwError","throwWarning","directiveHandlers","YAML","args","major","minor","version","checkLineBreaks","TAG","handle","prefix","tagMap","decodeURIComponent","captureSegment","start","end","checkJson","_position","_length","_character","_result","mergeMappings","destination","overridableKeys","quantity","storeMappingPair","keyTag","keyNode","valueNode","startLine","startLineStart","startPos","defineProperty","configurable","enumerable","writable","readLineBreak","skipSeparationSpace","allowComments","checkIndent","lineBreaks","testDocumentSeparator","writeFoldedLines","readBlockSequence","nodeIndent","_line","_tag","_anchor","anchor","detected","anchorMap","composeNode","readTagProperty","tagHandle","tagName","isVerbatim","isNamed","readAnchorProperty","parentIndent","nodeContext","allowToSeek","allowCompact","allowBlockStyles","allowBlockScalars","allowBlockCollections","typeIndex","typeQuantity","typeList","flowIndent","blockIndent","indentStatus","atNewLine","hasContent","following","_keyLine","_keyLineStart","_keyPos","atExplicitKey","readBlockMapping","_lineStart","_pos","terminator","isPair","isExplicitPair","isMapping","readNext","readFlowCollection","captureStart","folding","tmp","chomping","didReadContent","detectedIndent","textIndent","emptyLines","atMoreIndented","readBlockScalar","captureEnd","readSingleQuotedScalar","hexLength","hexResult","readDoubleQuotedScalar","readAlias","withinFlowCollection","hasPendingContent","_lineIndent","_kind","readPlainScalar","readDocument","directiveName","directiveArgs","documentStart","hasDirectives","loadDocuments","nullpos","loadAll_1","iterator","load_1","loader","loadAll","load","_toString","_hasOwnProperty","ESCAPE_SEQUENCES","DEPRECATED_BOOLEANS_SYNTAX","DEPRECATED_BASE60_SYNTAX","encodeHex","character","State","noArrayIndent","skipInvalid","flowLevel","styleMap","compileStyleMap","sortKeys","lineWidth","noRefs","noCompatMode","condenseFlow","quotingType","forceQuotes","replacer","explicitTypes","duplicates","usedDuplicates","indentString","spaces","ind","next","generateNextLine","level","isWhitespace","isPrintable","isNsCharOrWhitespace","isPlainSafe","prev","inblock","cIsNsCharOrWhitespace","cIsNsChar","codePointAt","first","needIndentIndicator","chooseScalarStyle","singleLineOnly","indentPerLevel","testAmbiguousType","char","prevChar","hasLineBreak","hasFoldableLine","shouldTrackWidth","previousLineBreak","plain","isPlainSafeLast","writeScalar","iskey","dump","testImplicitResolving","blockHeader","dropEndingNewline","width","moreIndented","lineRe","nextLF","lastIndex","foldLine","prevMoreIndented","foldString","escapeSeq","escapeString","indentIndicator","clip","breakRe","curr","writeBlockSequence","writeNode","detectType","isblockseq","tagStr","duplicateIndex","duplicate","objectOrArray","objectKey","objectValue","explicitPair","pairBuffer","objectKeyList","sort","writeBlockMapping","writeFlowMapping","writeFlowSequence","encodeURI","getDuplicateReferences","objects","duplicatesIndexes","inspectNode","dump_1","renamed","from","to","jsYaml","Type","Schema","FAILSAFE_SCHEMA","JSON_SCHEMA","CORE_SCHEMA","DEFAULT_SCHEMA","YAMLException","types","null","safeLoad","safeLoadAll","safeDump","Directive","assert","msg","assert_has_content","body","createToken","nesting","optional","undefined","nestedParse","initLine","pluginRuleName","includeRule","tempDisabledCore","rule","__rules__","reverse","disable","parse","enable","nestedCoreParse","DirectiveParsingError","directiveToData","directive","firstLine","arg","split","bodyOffset","option_spec","rawOptions","parseDirectiveOptions","required_arguments","optional_arguments","fullSpec","totalArgs","final_argument_whitespace","arr","splice","join","parseDirectiveArguments","shift","has_content","bodyMap","yamlBlock","startsWith","newContent","foundDivider","output","yaml","entries","convertor","converted_value","directivePlugin","directivesAfter","replaceFences","directives","finalTokens","directiveOpen","directiveClose","runDirectives","make_id","OptionSpecError","unchanged","unchanged_required","flag","class_option","argument","isInteger","nonnegative_int","optional_int","percentage","get_measure","units","groups","length_units","length_or_unitless","length_or_percentage_or_unitless","defaultUnit","length_or_percentage_or_unitless_figure","create_choice","choices","includes","uri","BaseAdmonition","class","adToken","attrJoin","adTokenTitle","bodyTokens","admonitions","admonition","attention","caution","danger","important","hint","note","seealso","tip","warning","force","linenos","dedent","caption","shared_option_spec","alt","height","scale","Image","align","create_image","altTokens","images","image","figure","figwidth","figclass","openToken","imageToken","captionTokens","legendTokens","legendParts","legend","captionMap","openCaption","legendMap","closeToken","SyntaxTreeNode","create_root","_set_children_from_tokens","inline_token","nester_tokens","opening","closing","revered_tokens","pop","_add_child","nested_tokens","parent","to_tokens","recursive_collect_tokens","node","token_list","is_root","is_nested","siblings","walk","include_self","endsWith","attribute_token","attrs","tables","widths","headerRows","listTokens","tableOpen","rowLength","colType","rowNumber","row","numbered","directivesDefault","statePlugin","setError","details","OptionDefaults","docutilsPlugin","fullOptions","use"],"mappings":"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"}